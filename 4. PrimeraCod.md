# Mis primeras clases en C++ 
## C++
### ¬øQu√© es un lenguaje compilado?

Un **lenguaje compilado** es aquel en el que el c√≥digo fuente (los archivos que escribimos con nuestra l√≥gica) se **traduce completamente** a c√≥digo m√°quina antes de ser ejecutado.

- **Traducci√≥n a c√≥digo m√°quina**: Significa que el programa queda en un formato que la computadora entiende directamente (un archivo ejecutable).
- **Ejemplos**: C, C++, Rust, Go.
- En C++, escribimos archivos `.cpp` y `.h`, luego usamos un programa llamado **compilador** (por ejemplo, `g++` en Linux/Mac o MinGW en Windows) que genera un **ejecutable** (por ejemplo, `miPrograma.exe` o `./miPrograma`).

> **Compilador**: Es un programa que lee tu c√≥digo fuente, lo analiza y lo transforma en un archivo binario listo para ejecutarse.

El hecho de que est√© "compilado" significa que una vez creado ese ejecutable, podemos ejecutarlo sin necesidad de un int√©rprete en el sistema final, siempre y cuando tengamos el sistema operativo adecuado y las librer√≠as requeridas.

---

### Comparaci√≥n con un lenguaje interpretado

Los **lenguajes interpretados** (como Python, JavaScript o PHP) no producen t√≠picamente un solo ejecutable aut√≥nomo, sino que **requieren** de un **int√©rprete** o **m√°quina virtual** para poder funcionar.

- **Int√©rprete**: Programa que lee el c√≥digo "l√≠nea a l√≠nea" o "instrucci√≥n a instrucci√≥n" y lo va ejecutando al momento.
- **M√°quina virtual**: Software que simula un entorno de ejecuci√≥n, muy com√∫n en lenguajes como Java.

**Ventajas de los interpretados**:
- Mayor **flexibilidad** y **rapidez de prototipado**.
- Suelen ser m√°s sencillos de depurar en tiempo real porque no requieren recompilar.

**Desventajas**:
- Al ejecutarse l√≠nea a l√≠nea, pueden ser m√°s **lentos** que un compilado, dependiendo del tipo de tarea.
- El usuario necesita el int√©rprete (o la m√°quina virtual) instalado.

---

### Ventajas de un lenguaje compilado

1. **Mayor velocidad de ejecuci√≥n**: Al no interpretarse en tiempo real, el tiempo de ejecuci√≥n suele ser menor.
2. **Optimizaciones del compilador**: El compilador puede analizar y optimizar el c√≥digo en diferentes fases (por ejemplo, reordenar instrucciones para que sean m√°s eficientes).
3. **Distribuci√≥n sencilla**: Puedes entregar el archivo ejecutable, y el usuario final no necesita tener un int√©rprete.

> **Ejecutable**: Archivo final que tu sistema operativo puede correr directamente, como `miPrograma.exe` en Windows o `./miPrograma` en Linux.

---

### Por qu√© puede ser m√°s r√°pido un lenguaje compilado

1. **Sin capa de interpretaci√≥n**: Al no traducir instrucci√≥n por instrucci√≥n en tiempo de ejecuci√≥n, se **ahorra** ese procesamiento adicional.
2. **Compilador**: Realiza **optimizaciones** a nivel de hardware, como usar mejor los registros de la CPU, "desenrollar bucles" (loop unrolling) o "insertar" llamadas de funciones simples (inlining), todo lo cual acelera la ejecuci√≥n.

---
### Tipado Fuerte y Diferencias con Python

Cuando decimos que un lenguaje es **fuertemente tipado**, nos referimos a que:

- Cada variable tiene un **tipo** (por ejemplo, `int`, `float`, `string`) y el compilador **exige** coherencia al usarlas.
- No se puede convertir una variable a otro tipo incompatible sin que el compilador reclame o requiera una conversi√≥n expl√≠cita.

> **Tipo**: Define qu√© clase de datos se almacenan en la variable (por ejemplo, n√∫meros enteros, texto, etc.) y qu√© operaciones se pueden realizar sobre ese valor.

**En C++**:

- Si declaras `int x = 10;`, no podr√°s asignarle directamente un `double*` o un `std::string` sin que ocurra un **error de compilaci√≥n**.
- La mayor√≠a de los errores de tipo se detectan antes de ejecutar el programa, haciendo que los errores aparezcan temprano en el proceso.

**En Python**:

- Python tambi√©n es **fuertemente tipado** (cada objeto en Python tiene un tipo), pero es **din√°micamente tipado** (no necesitas declarar el tipo antes de usarlo).
- Python hace muchas conversiones internamente y asocia los tipos a los **objetos**, no a las **variables**.
- Muchos errores de tipo se detectan en **tiempo de ejecuci√≥n** (es decir, cuando ya se est√° corriendo el programa).

**¬øBeneficio de C++?**

- El compilador **detecta** errores de tipo y problemas de sintaxis antes de ejecutar el programa, haci√©ndolo m√°s **robusto** y predecible.

#### Diferencias Claves entre Python y C++

| Caracter√≠stica           | Python                         | C++                                        |
| ------------------------ | ------------------------------ | ------------------------------------------ |
| **Tipado**               | Din√°mico (no tipado)           | Est√°tico (fuertemente tipado)              |
| **Definici√≥n de clases** | class sin tipos                | class con tipos especificados              |
| **Instanciaci√≥n**        | `obj = Clase()`                | `Clase obj;` o `Clase* obj = new Clase();` |
| **Memoria**              | Autom√°tica (Garbage Collector) | Manual (uso de `new` y `delete`)           |s librer√≠as necesarias, para formar el **ejecutable** final. Si faltan definiciones de funciones u otros s√≠mbolos, surgir√° un **error de enlazado**.

---

#- **Directivas de preprocesador**: Le indican al compilador (o m√°s espec√≠ficamente, al preprocesador) que realice tareas espec√≠ficas **antes** de compilar el c√≥digo principal. Por ejemplo:
  - `#include <iostream>`: Copia el contenido del archivo de cabecera (en este caso, de la librer√≠a de entrada y salida est√°ndar) en tu c√≥digo.
  - `#define MAX 100`: Define una constante o macro llamada `MAX` con el valor 100, que luego ser√° sustituido en el c√≥digo.

Durante el **preprocesado**, se **expanden** estas directivas. Para el caso de `#include`, se copia todo el contenido del archivo incluido dentro de tu archivo final, antes de pasar a la etapa de compilaci√≥n.

#### Compilaci√≥n

En la **compilaci√≥n**, el compilador traduce el c√≥digo fuente (ya preprocesado) de cada archivo `.cpp` a un archivo objeto (`.o` en Linux/macOS o `.obj` en Windows). En esta etapa se revisa la sintaxis, los tipos de datos, la correcci√≥n del c√≥digo, etc.

#### Enlazado (Linking)

En el **enlazado**, los distintos archivos objeto se unen entre s√≠, junto con las librer√≠as necesarias, para formar el **ejecutable** final. Si faltan definiciones de funciones u otros s√≠mbolos, surgir√° un **error de enlazado**.

---

**Ejemplo de compilaci√≥n**: Si tenemos un solo archivo `main.cpp`, podemos compilar y ejecutar en Linux/Mac:

```bash
g++ main.cpp -o miPrograma
./miPrograma
```

En Windows (con g++ de MinGW):

```bash
g++ main.cpp -o miPrograma.exe
miPrograma.exe
```

---

### ¬øQu√© se necesita para que un programa en C++ funcione?

1. **Compilador**: Necesitas contar con un compilador C++ instalado en tu sistema, por ejemplo `g++` o `clang++`. Este se encarga de traducir el c√≥digo fuente en un ejecutable.
2. **Bibliotecas est√°ndar**: C++ provee librer√≠as como `<iostream>` (para imprimir en consola), `<vector>`, `<string>`, etc. Estas librer√≠as normalmente vienen con el compilador.
3. **Sistema operativo**: El programa compilado deber√° ser compatible con el sistema operativo para el cual fue compilado (Windows, Linux, macOS, etc.).
4. **Ambiente de ejecuci√≥n**: Para programas de consola, solo necesitas el ejecutable y las bibliotecas asociadas (normalmente incluidas en la instalaci√≥n de C++). Para interfaces gr√°ficas u otras librer√≠as, debes asegurarte de que est√©n instaladas.

---

### Partes t√≠picas de un proyecto orientado a objetos en C++

En un proyecto de C++ de tama√±o mediano o grande, es com√∫n tener:

1. **Archivos de encabezado (`.h` o `.hpp`)**: Contienen las **declaraciones** de clases, funciones y constantes. Normalmente incluyen:
   - `#ifndef`, `#define`, `#endif` (las llamadas guardas de inclusi√≥n) para evitar que se incluya el archivo varias veces.

Ejemplo de una guarda en un archivo de encabezado:

```cpp
#ifndef MI_CLASE_H
#define MI_CLASE_H

class MiClase {
private:
    int atributo;
public:
    MiClase(int valor);
    int getAtributo();
};

#endif // MI_CLASE_H
```

En este ejemplo:
- `#ifndef MI_CLASE_H` verifica si `MI_CLASE_H` no ha sido definido antes.
- `#define MI_CLASE_H` lo define para que el archivo solo se procese una vez.
- `#endif` marca el final de la inclusi√≥n condicional.
   - `#include` de otras librer√≠as o encabezados necesarios.
   - Definiciones de las clases (atributos y m√©todos) pero sin la implementaci√≥n completa de las funciones.

2. **Archivos fuente (********`.cpp`********\*\*\*\*)**: Contienen las **implementaciones** de las clases y funciones declaradas en los archivos `.h`:

   - `#include "MiClase.h"` para poder implementar esas clases.
   - El cuerpo de cada m√©todo, usando el **operador de resoluci√≥n de √°mbito** (`::`) para indicar que pertenece a la clase declarada en el `.h`.

3. **Archivo principal (********`main.cpp`********\*\*\*\*)**: Es el **punto de entrada** del programa. All√≠ implementas la funci√≥n `int main()` que, al ejecutarse, inicia tu aplicaci√≥n.

4. **Fichero de construcci√≥n (CMakeLists.txt, Makefile, etc.)** (opcional pero muy recomendado para proyectos m√°s grandes): Indica al compilador c√≥mo compilar y enlazar los distintos archivos, qu√© librer√≠as incluir, etc. Por ejemplo, en proyectos con CMake, se define este archivo para especificar rutas, nombres de ejecutable, etc.

5. **Carpetas organizadas** (opcional, pero √∫til):

   - `include/` para archivos de encabezado.
   - `src/` para archivos fuente.
   - `build/` para colocar los archivos objeto y ejecutables.

---
### CLion: Un IDE para C++

Un **IDE (Integrated Development Environment)** es un programa que integra diversas herramientas de desarrollo en una sola aplicaci√≥n. Para C++, uno de los entornos m√°s populares y potentes es **CLion**, desarrollado por JetBrains. A continuaci√≥n, algunas de sus funcionalidades importantes y por qu√© usar un IDE puede resultar muy beneficioso:

1. **Edici√≥n con resaltado de sintaxis**: CLion reconoce la estructura de tu c√≥digo C++, colorea y formatea autom√°ticamente los elementos (palabras clave, variables, m√©todos, etc.). Esto facilita la lectura y ayuda a prevenir errores.
2. **Autocompletado inteligente (Code Completion)**: Mientras escribes, CLion sugiere nombres de variables, funciones, clases y m√©todos existentes en tu proyecto. Esto acelera la velocidad de programaci√≥n y reduce errores de tipeo.
3. **Depuraci√≥n (Debugging)**: Con CLion puedes poner puntos de interrupci√≥n (breakpoints), inspeccionar variables en tiempo real, ejecutar tu c√≥digo paso a paso y revisar el flujo para encontrar errores l√≥gicos.
4. **Integraci√≥n con CMake**: CMake es una herramienta de configuraci√≥n y compilaci√≥n multiplataforma. CLion se integra perfectamente con CMake, permiti√©ndote gestionar proyectos grandes sin complicaciones.
5. **Gesti√≥n de proyectos y archivos**: CLion te facilita organizar tus carpetas, archivos fuente, librer√≠as y dependencias en un solo lugar. Esto es √∫til para mantener una estructura clara en proyectos de tama√±o mediano o grande.
6. **Control de versiones**: CLion ofrece integraci√≥n con sistemas como Git o SVN. Puedes hacer commits, push, pull, ver el historial de cambios, etc., directamente desde el IDE.
7. **Refactorizaci√≥n**: Herramientas que permiten cambiar el nombre de variables, extraer funciones, reestructurar clases, todo de manera autom√°tica y segura. El IDE se encarga de aplicar los cambios en todos los lugares donde se use ese c√≥digo.
8. **Productividad y mantenimiento**: Al unificar la edici√≥n de c√≥digo, la compilaci√≥n, la depuraci√≥n y la gesti√≥n de versiones, CLion ayuda a que el flujo de trabajo sea m√°s √°gil y mantenible.

> **¬øPor qu√© es importante usar un IDE como CLion?**
>
> - **Ahorra tiempo**: automatiza tareas comunes, como la compilaci√≥n y la generaci√≥n de archivos.
> - **Ayuda a encontrar errores**: el resaltado de sintaxis y el debugging integrado facilitan la detecci√≥n de fallos.
> - **Favorece el aprendizaje**: ver los avisos de error inmediatamente, contar con autocompletado y ver ejemplos de uso refuerza la comprensi√≥n del lenguaje.
> - **Entorno unificado**: todo en un solo lugar: editor, compilador, debugger, control de versiones, etc.

---
## Programaci√≥n orientada a objetos en C++
Para entender la **Programaci√≥n Orientada a Objetos (POO) en C++**, primero debemos retomar dos conceptos clave: **clases** y **objetos**.

1. **Clase**: Es una plantilla o modelo que define c√≥mo ser√° un objeto, qu√© datos tendr√° y qu√© podr√° hacer. Es como un plano de construcci√≥n para un edificio: describe la estructura, pero a√∫n no es un edificio real.
2. **Objeto**: Es una instancia de la clase, es decir, una versi√≥n concreta de ese modelo con valores espec√≠ficos. Siguiendo la analog√≠a del edificio, un objeto ser√≠a un edificio real construido a partir del plano. **Instanciar**: Significa crear un objeto a partir de una clase. Es el proceso de dar vida a una clase y asignarle valores espec√≠ficos.

La **Programaci√≥n Orientada a Objetos (POO)** se basa en el uso de **objetos**, no solo en la definici√≥n de **clases**. Una clase por s√≠ sola es solo una idea, un molde o un dise√±o. Sin objetos, el c√≥digo no hace nada √∫til.

### Ejemplo simple: Receta de galletas üç™

Imagina que una **clase** es una receta para hacer galletas. La receta dice qu√© ingredientes usar y c√≥mo mezclarlos, pero no es una galleta real, solo una instrucci√≥n.

Cuando sigues la receta y horneas una galleta, est√°s **instanciando** una galleta basada en la receta. Cada galleta tiene los mismos ingredientes, pero pueden tener decoraciones diferentes.

En C++:

```cpp
class Galleta {
public:
    string sabor;
    int tama√±o;
};

int main() {
    Galleta g1; // Creamos una galleta (instancia de la clase Galleta)
    g1.sabor = "Chocolate";
    g1.tama√±o = 10;
    
    Galleta g2; // Otra galleta con diferentes atributos
    g2.sabor = "Vainilla";
    g2.tama√±o = 8;

    cout << "Galleta 1: " << g1.sabor << " - Tama√±o: " << g1.tama√±o << endl;
    cout << "Galleta 2: " << g2.sabor << " - Tama√±o: " << g2.tama√±o << endl;
    return 0;
}
```

Aqu√≠:

- `Galleta` es la clase (receta).
- `g1` y `g2` son objetos (galletas creadas a partir de la receta).
- Cada galleta tiene un sabor y un tama√±o diferente.

### Diferencia entre una clase y un objeto

### 1. Una clase sin objetos es como un plano sin construcci√≥n

Imagina que tienes el plano de una casa. El plano te dice cu√°ntas habitaciones hay, d√≥nde van las puertas y ventanas, y c√≥mo se ver√° la casa. Pero **sin construir la casa**, el plano no sirve para vivir en √©l.

En POO, una clase es como ese plano: define las caracter√≠sticas de los objetos, pero si no creamos objetos (instanciamos la clase), el programa no hace nada √∫til.

Ejemplo en C++:

```cpp
class Auto {
public:
    string marca;
    int velocidad;
};
```

Esta clase `Auto` solo existe como una idea, pero no tiene uso real hasta que creamos objetos a partir de ella:

```cpp
int main() {
    Auto miAuto; // Ahora la clase cobra vida como un objeto
    miAuto.marca = "Toyota";
    miAuto.velocidad = 120;
    
    cout << "Marca: " << miAuto.marca << ", Velocidad: " << miAuto.velocidad << " km/h" << endl;
    return 0;
}
```

Aqu√≠ `miAuto` es un objeto de la clase `Auto`. Ahora, el programa tiene datos concretos y puede ejecutarse.

---

### 2. Los objetos almacenan y manipulan datos

Los objetos permiten **guardar informaci√≥n espec√≠fica y manipularla**. Sin objetos, no podr√≠amos representar datos reales en un programa.

Ejemplo:

```cpp
class Persona {
public:
    string nombre;
    int edad;
    void saludar() {
        cout << "Hola, soy " << nombre << " y tengo " << edad << " a√±os." << endl;
    }
};
```

Si solo tenemos esta clase, el programa no hace nada. Pero si creamos objetos:

```cpp
int main() {
    Persona p1;
    p1.nombre = "Sofia";
    p1.edad = 22;
    
    p1.saludar(); // Llamamos a un m√©todo en el objeto
    return 0;
}
```

Ahora, el programa muestra:

```
Hola, soy Sofia y tengo 22 a√±os.
```

Esto demuestra c√≥mo un objeto **almacena datos y ejecuta acciones**, algo que una clase por s√≠ sola no puede hacer.

---

### 3. Los objetos permiten reutilizaci√≥n y organizaci√≥n del c√≥digo

En lugar de escribir c√≥digo repetitivo, podemos crear m√∫ltiples objetos de una misma clase. Esto hace que nuestro c√≥digo sea **modular y reutilizable**.

Ejemplo:

```cpp
int main() {
    Persona p1, p2;
    p1.nombre = "Carlos";
    p1.edad = 30;
    
    p2.nombre = "Ana";
    p2.edad = 25;
    
    p1.saludar();
    p2.saludar();
    return 0;
}
```

Salida del programa:

```
Hola, soy Carlos y tengo 30 a√±os.
Hola, soy Ana y tengo 25 a√±os.
```

Esto demuestra que podemos crear m√∫ltiples objetos a partir de la misma clase, cada uno con su propia informaci√≥n.

---

### 4. Los objetos reflejan c√≥mo funciona el mundo real

En el mundo real, todo lo que usamos son "objetos" con propiedades y comportamientos. Por ejemplo:

- Un **carro** tiene una marca, un modelo y una velocidad (atributos), y puede acelerar o frenar (m√©todos).
- Una **cuenta bancaria** tiene un saldo y un n√∫mero de cuenta (atributos), y permite hacer dep√≥sitos y retiros (m√©todos).
- Un **usuario** en una red social tiene un nombre y amigos (atributos), y puede publicar mensajes y comentar (m√©todos).

La POO busca **representar estos objetos reales dentro de un programa**.

---

## Preguntas Frecuentes sobre la Creaci√≥n de Objetos e Instanciaci√≥n

### 1. ¬øCu√°ntas instancias puedo tener de una clase?

Puedes crear tantas instancias como necesites. Cada objeto creado a partir de una clase ocupa su propio espacio en la memoria y puede tener valores distintos en sus atributos.

Ejemplo:

```cpp
class Persona {
public:
    string nombre;
    int edad;
};

int main() {
    Persona p1;
    Persona p2;
    Persona p3;
    return 0;
}
```

Aqu√≠ hemos creado tres objetos (`p1`, `p2`, `p3`) de la misma clase `Persona`.

---

### 2. ¬øC√≥mo se diferencia un objeto de otro?

Cada objeto tiene su propia copia de los atributos definidos en la clase, lo que le permite almacenar informaci√≥n diferente.

Ejemplo:

```cpp
Persona p1;
p1.nombre = "Carlos";
p1.edad = 20;

Persona p2;
p2.nombre = "Ana";
p2.edad = 25;
```

Aunque `p1` y `p2` provienen de la misma clase `Persona`, tienen valores diferentes en sus atributos.

---

### 3. ¬øPara qu√© sirven los atributos y los m√©todos en una clase?

- **Atributos**: Son las variables que almacenan la informaci√≥n de un objeto. Por ejemplo, el nombre y la edad de una persona.
- **M√©todos**: Son funciones dentro de la clase que permiten interactuar con los atributos y realizar acciones.

Ejemplo:

```cpp
class Persona {
public:
    string nombre;
    int edad;
    void mostrarInfo() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};
```

Aqu√≠, `mostrarInfo()` es un m√©todo que imprime la informaci√≥n de la persona.

---

### 4. ¬øQu√© es el estado de un objeto y por qu√© es importante?

El **estado** de un objeto es el conjunto de valores que tienen sus atributos en un momento determinado. Cambiar los valores de los atributos modifica el estado del objeto.

Ejemplo:

```cpp
Persona p1;
p1.nombre = "Luis";
p1.edad = 30;

// Cambiamos el estado del objeto
p1.nombre = "Mario";
p1.edad = 40;
```

El estado inicial de `p1` era `nombre = "Luis"`, `edad = 30`. Despu√©s lo modificamos a `nombre = "Mario"`, `edad = 40`.

Comprender el concepto de estado es clave para entender c√≥mo los objetos cambian con el tiempo en un programa.

---

### ¬øPara qu√© sirven los getters y setters?
En POO, uno de los principios clave es la encapsulaci√≥n, que consiste en ocultar los detalles internos de una clase y exponer solo lo necesario al exterior. Los m√©todos que usamos para leer (obtener) o modificar (establecer) los valores internos de los atributos de una clase se conocen como getters y setters.

Getters (m√©todos de acceso): Permiten obtener el valor de un atributo privado de la clase.

Por convenci√≥n, suelen nombrarse con el prefijo get seguido del nombre del atributo (por ejemplo, getNombre(), getEdad()).
Setters (m√©todos modificadores): Permiten cambiar el valor de un atributo privado de la clase.

Por convenci√≥n, suelen nombrarse con el prefijo set seguido del nombre del atributo (por ejemplo, setNombre(...), setEdad(...)).

**¬øPor qu√© encapsular?**
* Control: Podemos validar o filtrar datos antes de asignarlos.
* Seguridad: Evitamos que otras partes del c√≥digo modifiquen directamente valores cr√≠ticos.
* Mantenibilidad: Si en el futuro cambiamos la forma en que guardamos un atributo, no rompemos todo el c√≥digo. Solo actualizamos el m√©todo setter/getter.

Ejemplo de getters y setters en C++
```cpp
#ifndef PERSONA_H
#define PERSONA_H

#include <string>

class Persona {
private:
    std::string nombre;
    int edad;

public:
    // Constructor con par√°metros
    Persona(std::string nombre, int edad);

    // Getters
    std::string getNombre();
    int getEdad();

    // Setters
    void setNombre(std::string nuevoNombre);
    void setEdad(int nuevaEdad);
};

#endif // PERSONA_H



#include "Persona.h"

// Constructor
Persona::Persona(std::string nombre, int edad) {
  Persona::nombre = nombre;
  Persona::edad = edad; 

}

// Getter para nombre
std::string Persona::getNombre() {
    return nombre;
}

// Setter para nombre
void Persona::setNombre(std::string nuevoNombre) {
    if (!nuevoNombre.empty()) {
        nombre = nuevoNombre;
    }
}

// Getter para edad
int Persona::getEdad() {
    return edad;
}

// Setter para edad
void Persona::setEdad(int nuevaEdad) {
    if (nuevaEdad > 0) {
        edad = nuevaEdad;
    }
}

```
En este ejemplo, la clase Persona mantiene sus atributos nombre y edad como privados (private). Cualquier acceso o modificaci√≥n a estos atributos se hace mediante los m√©todos getNombre(), setNombre(...), getEdad() y setEdad(...). De esta forma, podemos validar o filtrar la informaci√≥n antes de asignarla, y protegemos los datos internos de la clase.

### ¬øQu√© son los constructores y c√≥mo se crean?
Un constructor en C++ es una funci√≥n especial que se ejecuta autom√°ticamente al crear (instanciar) un objeto de una clase. Tiene las siguientes caracter√≠sticas:

* Mismo nombre que la clase: Si la clase se llama Persona, el constructor se llamar√° Persona(...).
* No tiene tipo de retorno (ni siquiera void).
* Puede recibir par√°metros o no (constructor por defecto o sin par√°metros).
* Se usa para inicializar los atributos de la clase.

#### Constructor sin par√°metros
Un constructor sin par√°metros (tambi√©n llamado constructor por defecto) no recibe ning√∫n argumento. √ötil cuando no queremos ‚Äîo no podemos‚Äî suministrar datos de inicializaci√≥n en el momento de crear el objeto. Podemos asignar valores por defecto a los atributos dentro de este constructor.

Ejemplo
```cpp
#ifndef PERSONA_H
#define PERSONA_H

#include <string>

class Persona {
private:
    std::string nombre;
    int edad;

public:
    // Constructor sin parametros
    Persona();

    // Constructor con par√°metros
    Persona(std::string nombre, int edad);

    // Getters
    std::string getNombre();
    int getEdad();

    // Setters
    void setNombre(std::string nuevoNombre);
    void setEdad(int nuevaEdad);
};

#endif // PERSONA_H



#include "Persona.h"

// Constructor sin par√°metros (por defecto)
Persona() {
    nombre = "Desconocido";
    edad   = 0;
}

// Constructor
Persona::Persona(std::string nombre, int edad) {
  Persona::nombre = nombre;
  Persona::edad = edad; 

}

// Getter para nombre
std::string Persona::getNombre() {
    return nombre;
}

// Setter para nombre
void Persona::setNombre(std::string nuevoNombre) {
    if (!nuevoNombre.empty()) {
        nombre = nuevoNombre;
    }
}

// Getter para edad
int Persona::getEdad() {
    return edad;
}

// Setter para edad
void Persona::setEdad(int nuevaEdad) {
    if (nuevaEdad > 0) {
        edad = nuevaEdad;
    }
}

// Archivo Main

int main() {
    // Uso del constructor sin par√°metros
    Persona persona1;
    // persona1 tiene nombre "Desconocido" y edad 0.

    // Uso del constructor con par√°metros
    Persona persona2("Ana", 25);

    // Mostramos los resultados
    std::cout << "Persona 1: " << persona1.getNombre()
              << ", " << persona1.getEdad() << " a√±os.\n";

    std::cout << "Persona 2: " << persona2.getNombre()
              << ", " << persona2.getEdad() << " a√±os.\n";
    
    return 0;
}
```
En este ejemplo:
```
Persona(): Constructor sin par√°metros. Asigna valores por defecto ("Desconocido" y 0).
Persona(std::string, int): Constructor con par√°metros. Inicializa nombre y edad con los valores dados.
Nota: Si no definimos ning√∫n constructor, el compilador genera un constructor por defecto autom√°ticamente. Sin embargo, si definimos un constructor con par√°metros, el constructor por defecto no se genera autom√°ticamente (a menos que lo declaremos expl√≠citamente).
```

## Dise√±o UML y Ejemplo Pr√°ctico en C++
Ahora que hemos revisado los fundamentos de la compilaci√≥n, las partes t√≠picas de un proyecto en C++ y c√≥mo estructurar nuestro c√≥digo fuente, vamos a llevar todo ese conocimiento a la pr√°ctica. En esta secci√≥n, dise√±aremos un programa orientado a objetos mediante UML y luego mostraremos la transici√≥n de ese dise√±o al c√≥digo en C++.

### ¬øC√≥mo se asocian los atributos y m√©todos definidos en UML con la parte pr√°ctica?
Cuando dise√±amos nuestras clases en UML, definimos sus **atributos** (por ejemplo, `nombre`, `id`) y sus **m√©todos** (por ejemplo, `getNombre()`, `setNombre()`), junto con las relaciones (asociaciones, agregaciones, etc.). En C++:

- **Atributos**: se convierten en **variables miembro** dentro de nuestras clases en los archivos `.h`. Normalmente los colocamos como `private` para mantener el encapsulamiento.
- **M√©todos**: se declaran en el archivo `.h` como funciones dentro de la clase, y se **implementan** en el archivo `.cpp` usando el operador de resoluci√≥n de √°mbito (`Clase::metodo`).
- **Relaciones**: si en UML decimos que un `Profesor` puede dictar varios `Curso`, usamos un contenedor, por ejemplo `std::vector<Curso>`, para representar esa relaci√≥n en C++.
- **main**: la parte pr√°ctica se concreta en `main.cpp`, donde instanciamos nuestros objetos y comprobamos su funcionamiento. Recuerda que solo puede existir un `main`.

Gracias a esta separaci√≥n (declaraciones en `.h`, implementaci√≥n en `.cpp`, y punto de entrada en `main.cpp`), el proyecto adquiere un orden claro. Si quieres modificar atributos de `Profesor`, cambias su declaraci√≥n en el header (`.h`), implementas la l√≥gica que necesites en el `.cpp`, y usas esos cambios en tu `main.cpp`.

## Ejercicios Pr√°cticos de Clases y UML

A continuaci√≥n, se presentan **tres ejercicios** para reforzar lo aprendido. Cada ejercicio incluye un **diagrama UML** y una consigna de programaci√≥n en C++.

---

### Ejercicio 1

#### Instrucciones

1. Observa el siguiente diagrama UML que representa una **sola clase** llamada `Libro`.  
2. Implementa la clase en C++:  
   - Declara sus atributos de manera **privada**.  
   - Crea los **getters y setters** para cada atributo.  
   - Escribe al menos un **constructor** para inicializar los atributos.  
3. En el archivo `main.cpp`, crea **tres objetos** de tipo `Libro` con atributos distintos y muestra por pantalla los valores de cada uno.

#### Diagrama UML

```mermaid
classDiagram
    class Libro {
        -string titulo
        -string autor
        -int anioPublicacion
        +Libro(string, string, int)
        +string getTitulo()
        +void setTitulo(string)
        +string getAutor()
        +void setAutor(string)
        +int getAnioPublicacion()
        +void setAnioPublicacion(int)
    }
```


### Ejercicio 2

#### Instrucciones

1. Analiza el siguiente diagrama UML con **dos clases**: `Persona` y `Automovil`.  
2. Las clases tienen una **relaci√≥n de asociaci√≥n**: cada `Persona` **posee** un `Automovil`.  
3. Implementa ambas clases en C++ con sus getters, setters y un constructor que inicialice los atributos.  
4. Relaciona los objetos en tu `main.cpp`:
   - Crea al menos **dos objetos** de tipo `Persona`.
   - A cada persona, as√≠gnale un `Automovil`.
   - Muestra la relaci√≥n persona-autom√≥vil en la salida (por ejemplo, *"La persona Juan conduce un Toyota 2020"*).

#### Diagrama UML

```mermaid
classDiagram
    class Persona {
        -string nombre
        -int edad
        -Automovil miAuto
        +Persona(string, int, Automovil)
        +string getNombre()
        +void setNombre(string)
        +int getEdad()
        +void setEdad(int)
        +Automovil getMiAuto()
        +void setMiAuto(Automovil)
    }

    class Automovil {
        -string marca
        -int anio
        +Automovil(string, int)
        +string getMarca()
        +void setMarca(string)
        +int getAnio()
        +void setAnio(int)
    }

    Persona --> Automovil
```
### Enunciado completo: Dise√±a UML con Profesor, Curso y Sal√≥n

Imagina que trabajas en la Oficina de Registro Acad√©mico de la **Universidad XYZ**. El objetivo principal es organizar la informaci√≥n sobre la asignaci√≥n de cursos a los profesores asociados y sobre en qu√© salones se dicta cada curso. Se sabe lo siguiente:

- **Profesor**: Persona que dicta uno o varios cursos. Adem√°s de su nombre e identificaci√≥n, puede estar asociado a m√∫ltiples cursos.
- **Curso**: Toda asignatura que ofrece la universidad. Cada curso tiene un nombre, un c√≥digo √∫nico y se imparte en un √∫nico sal√≥n.
- **Sal√≥n**: Espacio f√≠sico en el campus universitario. Se identifica por un nombre o n√∫mero y tiene una capacidad limitada de estudiantes.

La **gerencia de la universidad** desea que se dise√±e un sistema para:

1. **Administrar** los datos de cada profesor (nombre, ID) y los cursos que dicta.
2. **Controlar** la informaci√≥n de cada curso (nombre, c√≥digo) y el sal√≥n asignado.
3. **Monitorear** las caracter√≠sticas del sal√≥n (nombre, capacidad).

En la pr√°ctica:

- Un Profesor puede dictar uno **o varios** cursos a lo largo de un per√≠odo.
- Cada Curso se dicta en un **solo Sal√≥n**, el cual determina cu√°ntos estudiantes se pueden matricular.

**Pr√°ctica**: A partir de esta historia, dise√±a un **diagrama UML** (usando la sintaxis de **mermaid**) que represente las clases `Profesor`, `Curso` y `Salon`. Luego, implementa las clases en C++ separando la declaraci√≥n (`.h`) de la implementaci√≥n (`.cpp`) y crea un programa (`main.cpp`) que demuestre la creaci√≥n de objetos y la relaci√≥n entre ellos. Aseg√∫rate de contar con al menos cuatro objetos en tu programa: por ejemplo, un par de profesores, un par de cursos y los salones correspondientes.

Recuerda que el objetivo de este ejercicio es **fortalecer tus habilidades** para identificar clases, m√©todos y atributos a partir de una historia y representarlos en UML para luego llevarlos al c√≥digo. ** TRATA DE HACERLO TU SOLO ANTES DE REVISAR LA SOLUCI√ìN - INVESTIGA PARA QUE SIRVE LA CLASE VECTOR EN C++**

### Soluci√≥n paso a paso

#### 1. Diagrama UML en mermaid

```mermaid
classDiagram
    class Profesor {
        -string nombre
        -string id
        -Vector cursos
        +Profesor(string nombre, string id)
        +void agregarCurso(Curso curso)
    }

    class Curso {
        -string nombreCurso
        -int codigo
        -Salon salon
        +Curso(string nombreCurso, int codigo)
        +void asignarSalon(Salon s)
    }

    class Salon {
        -string nombreSalon
        -int capacidad

        +Salon(string nombreSalon, int capacidad)
    }

    Profesor o-- Curso 
    Curso --> Salon 
```

En el diagrama:

- Se muestra una **agregaci√≥n** (`o--`) de `Profesor` a varios `Curso` (1 a muchos). Esto indica que un profesor tiene una relaci√≥n de propiedad parcial sobre los cursos, pero los cursos pueden existir sin el profesor.
- `Curso` tiene una **asociaci√≥n** unidireccional (`-->`) con `Salon`, reflejando que un curso ‚Äúconoce‚Äù el sal√≥n donde se dicta, pero el sal√≥n no necesita conocer al curso.

#### 2. C√≥digo fuente en C++

A continuaci√≥n, explicamos **paso a paso** la transici√≥n a c√≥digo en C++.

1. **Archivos .h** (cabeceras):

   - Empiezan con **guardas de inclusi√≥n** (`#ifndef`, `#define` y `#endif`) para evitar que se incluyan duplicadamente.
   - Se declaran las clases, sus atributos y los m√©todos que tendr√°n.
   - Se pueden incluir otras cabeceras necesarias, por ejemplo `#include <string>`.

2. **Archivos .cpp** (implementaci√≥n):

   - Incluyen la cabecera `.h` para acceder a la declaraci√≥n de la clase.
   - Desarrollan el **cuerpo** de cada m√©todo, usando el **operador de resoluci√≥n de √°mbito** (`Clase::metodo`) para indicar a qu√© clase pertenece. 

<details>
<summary><b>¬øQu√© es el operador de resoluci√≥n de √°mbito (::) en C++?</b></summary>

El **operador de resoluci√≥n de √°mbito (`::`)** en C++ se utiliza para especificar a qu√© espacio de nombres o a qu√© clase pertenece un identificador. Esto es fundamental cuando definimos los m√©todos de una clase en un archivo `.cpp` despu√©s de haberlos declarado en su correspondiente archivo `.h`.

Ejemplo:

```cpp
class Profesor {
public:
    void mostrarNombre();
};
```

En el archivo `.cpp`, definimos el m√©todo utilizando `::` para indicar que pertenece a `Profesor`:

```cpp
#include "Profesor.h"
#include <iostream>

void Profesor::mostrarNombre() {
    std::cout << "Nombre del profesor" << std::endl;
}
```

En este caso, `Profesor::mostrarNombre()` indica que el m√©todo `mostrarNombre` pertenece a la clase `Profesor`. Si no us√°ramos `::`, el compilador no sabr√≠a a qu√© clase pertenece la funci√≥n.

</details>
   - Pueden incluir librer√≠as adicionales si se necesitan.

3. **Archivo main.cpp**:

   - Incluye las cabeceras principales (por ejemplo `#include "Profesor.h"`, `#include "Curso.h"`, `#include "Salon.h"`).
   - Define la funci√≥n `int main()`, que es el punto de entrada de la aplicaci√≥n.
   - All√≠, creas objetos, llamas m√©todos, etc.

A continuaci√≥n, se muestra un ejemplo concreto:

##### 2.1 Profesor.h

```cpp
#ifndef PROFESOR_H
#define PROFESOR_H

// Librer√≠as necesarias
#include <string>
#include <vector>
#include "Curso.h"  // Para que Profesor sepa sobre la clase Curso

// Declaraci√≥n de la clase Profesor
class Profesor {
private:
    // Atributos
    std::string nombre;
    std::string id;
    std::vector<Curso> cursos; // Contenedor de cursos

public:
    // Constructor
    Profesor(std::string nombre, std::string id);

    // M√©todos de acceso (getters)
    std::string getNombre();
    std::string getId();

    // M√©todos para modificar (setters)
    void setNombre(std::string nombre);
    void setId(std::string id);

    // Otros m√©todos
    void agregarCurso(Curso curso);
    std::vector<Curso> getCursos();
};

#endif
```

1. Usamos `#ifndef PROFESOR_H` y `#define PROFESOR_H` para que este archivo s√≥lo se cargue una vez.
2. Incluimos `<string>` y `<vector>` porque los usamos en los atributos y m√©todos. Tambi√©n `Curso.h` para poder declarar un vector de tipo `Curso`.
3. Declaramos la clase `Profesor` con sus atributos privados y m√©todos p√∫blicos.

##### 2.2 Profesor.cpp

```cpp
#include "Profesor.h"  // Incluimos la cabecera correspondiente

// Definici√≥n del constructor
Profesor::Profesor(std::string nombre, std::string id)
{
  Profesor::nombre = nombre;
  Profesor::id = id;
}

// Definici√≥n de m√©todos
std::string Profesor::getNombre() {
    return nombre;
}

std::string Profesor::getId() {
    return id;
}

void Profesor::setNombre(std::string nombre) {
    this->nombre = nombre;
}

void Profesor::setId(std::string id) {
    this->id = id;
}

void Profesor::agregarCurso(Curso curso) {
    cursos.push_back(curso);
}

std::vector<Curso> Profesor::getCursos() {
    return cursos;
}
```

1. Incluimos `"Profesor.h"` para que el compilador conozca la declaraci√≥n de la clase.
2. Usamos `Profesor::Profesor(...)` para definir el **constructor**.
3. En el **inicializador** asignamos los valores recibidos a los atributos.
4. El resto de m√©todos se implementan usando la forma `TipoRetorno Clase::metodo() {...}`.

##### 2.3 Curso.h

```cpp
#ifndef CURSO_H
#define CURSO_H

#include <string>
#include "Salon.h" // Para relacionar Curso con Salon

class Curso {
private:
    std::string nombreCurso;
    int codigo;
    Salon salonAsignado;

public:
    Curso(std::string nombreCurso, int codigo);

    std::string getNombreCurso();
    int getCodigo();

    void setNombreCurso(std::string nombreCurso);
    void setCodigo(int codigo);

    void asignarSalon(Salon salon);
    Salon getSalonAsignado();
};

#endif
```

##### 2.4 Curso.cpp

```cpp
#include "Curso.h"

Curso::Curso(std::string nombreCurso, int codigo){
  Curso::nombreCurso = nombreCurso;
  Curso::codigo = codigo;
}

std::string Curso::getNombreCurso() {
    return nombreCurso;
}

int Curso::getCodigo() {
    return codigo;
}

void Curso::setNombreCurso(std::string nombreCurso) {
    this->nombreCurso = nombreCurso;
}

void Curso::setCodigo(int codigo) {
    this->codigo = codigo;
}

void Curso::asignarSalon(Salon salon) {
    salonAsignado = salon;
}

Salon Curso::getSalonAsignado() {
    return salonAsignado;
}
```

Aqu√≠ se implementan todos los m√©todos del curso y se guarda el `Salon` asignado.

##### 2.5 Salon.h

```cpp
#ifndef SALON_H
#define SALON_H

#include <string>

class Salon {
private:
    std::string nombreSalon;
    int capacidad;

public:
    Salon(std::string nombreSalon, int capacidad);

    std::string getNombreSalon();
    int getCapacidad();

    void setNombreSalon(std::string nombreSalon);
    void setCapacidad(int capacidad);
};

#endif
```

##### 2.6 Salon.cpp

```cpp
#include "Salon.h"

Salon::Salon(std::string nombreSalon, int capacidad){
  Salon::nombreSalon = nombreSalon;
  Salon::capacidad = capacidad;
}

std::string Salon::getNombreSalon() {
    return nombreSalon;
}

int Salon::getCapacidad() {
    return capacidad;
}

void Salon::setNombreSalon(std::string nombreSalon) {
    this->nombreSalon = nombreSalon;
}

void Salon::setCapacidad(int capacidad) {
    this->capacidad = capacidad;
}
```

##### 2.7 main.cpp

```cpp
#include <iostream>
#include "Profesor.h"
#include "Curso.h"
#include "Salon.h"

int main() {
    // 1. Creamos un objeto Salon
    Salon salon101("Salon 101", 30);

    // 2. Creamos un Curso y lo asignamos al salon anterior
    Curso poo("Programaci√≥n Orientada a Objetos", 1001);
    poo.asignarSalon(salon101);

    // 3. Creamos un Profesor y le agregamos el curso
    Profesor profJuan("Juan Perez", "P001");
    profJuan.agregarCurso(poo);

    // 4. Creamos otro Sal√≥n, otro Curso y otro Profesor
    Salon salon202("Salon 202", 50);
    Curso algebra("Algebra Lineal", 2002);
    algebra.asignarSalon(salon202);

    Profesor profMaria("Maria Lopez", "P002");
    profMaria.agregarCurso(algebra);

    // Mostramos informaci√≥n por consola
    std::cout << "Profesor: " << profJuan.getNombre()
              << " dicta el curso: "
              << profJuan.getCursos()[0].getNombreCurso()
              << " en el salon: "
              << profJuan.getCursos()[0].getSalonAsignado().getNombreSalon()
              << std::endl;

    std::cout << "Otro profesor: " << profMaria.getNombre()
              << " dicta el curso: "
              << profMaria.getCursos()[0].getNombreCurso()
              << " en el salon: "
              << profMaria.getCursos()[0].getSalonAsignado().getNombreSalon()
              << std::endl;

    return 0;
}
```

1. Incluimos `<iostream>` para poder usar `std::cout`.
2. Incluimos los encabezados (`Profesor.h`, `Curso.h`, `Salon.h`) para poder crear objetos de esas clases.
3. Creamos varios objetos y los relacionamos tal como definimos en el diagrama UML.
4. Finalmente, usamos `std::cout` para imprimir datos de inter√©s y comprobar que la relaci√≥n entre objetos funciona correctamente.

##### 2.8 Compilaci√≥n

Para compilar un proyecto en C++ de manera eficiente, especialmente en proyectos con m√∫ltiples archivos, es recomendable utilizar un sistema de construcci√≥n como **CMake**. En un archivo `CMakeLists.txt`, se especifican los archivos fuente, el compilador a usar y las opciones de compilaci√≥n.

Ejemplo de un `CMakeLists.txt` b√°sico para este proyecto:

```cmake
cmake_minimum_required(VERSION 3.10)
project(MiProyecto)

set(CMAKE_CXX_STANDARD 20)

add_executable(miPrograma 
    Profesor.cpp 
    Curso.cpp 
    Salon.cpp 
    main.cpp)
```

Este archivo define:
- El nombre del proyecto (`MiProyecto`).
- La versi√≥n m√≠nima de CMake requerida.
- El est√°ndar de C++ a utilizar (`C++20`).
- Los archivos fuente que deben compilarse en un ejecutable (`miPrograma`).

<details>
<summary><b>Compilar sin CMake (solo con g++)</b></summary>

Si todos estos archivos (`Profesor.h`, `Profesor.cpp`, `Curso.h`, `Curso.cpp`, `Salon.h`, `Salon.cpp`, y `main.cpp`) est√°n en la misma carpeta, se pueden compilar manualmente con:

```bash
g++ Profesor.cpp Curso.cpp Salon.cpp main.cpp -o miPrograma
./miPrograma
```

En Windows (con g++ de MinGW):

```bash
g++ Profesor.cpp Curso.cpp Salon.cpp main.cpp -o miPrograma.exe
miPrograma.exe
```
</details>

