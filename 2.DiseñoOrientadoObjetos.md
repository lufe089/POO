# Gu√≠a de Estudio: Dise√±o Orientado a Objetos

## **1. Introducci√≥n**

### **1.1 Conectando GitHub con la Programaci√≥n Orientada a Objetos**

Hasta ahora, has aprendido a usar Git y GitHub para gestionar versiones de c√≥digo y colaborar en proyectos. Sin embargo, escribir c√≥digo sin una estructura bien definida puede llevar a sistemas dif√≠ciles de mantener y escalar. El desarrollo de software no solo consiste en escribir c√≥digo funcional, sino tambi√©n en asegurarse de que ese c√≥digo sea claro, modular y f√°cil de modificar en el futuro. Aqu√≠ es donde entra la **Programaci√≥n Orientada a Objetos (POO)**: un enfoque que organiza el c√≥digo en **clases y objetos**, facilitando su reutilizaci√≥n y mantenimiento.

La **reutilizaci√≥n del c√≥digo** permite ahorrar tiempo y esfuerzo, evitando la necesidad de escribir las mismas funciones una y otra vez. Esto no solo optimiza el trabajo del programador, sino que tambi√©n mejora la estabilidad y consistencia del software. Por otro lado, el **mantenimiento** es clave para la evoluci√≥n de un sistema, ya que a medida que crecen los proyectos, es necesario actualizar funcionalidades, corregir errores y adaptarse a nuevos requisitos sin afectar otras partes del c√≥digo.

Muchos sistemas empresariales y aplicaciones que usamos a diario han sido desarrollados con estos principios. Desde redes sociales hasta plataformas de comercio electr√≥nico, la capacidad de reutilizar c√≥digo y mantenerlo f√°cilmente es lo que permite que estos sistemas sean escalables y confiables a lo largo del tiempo.

### **1.2 Relaci√≥n con el Mundo Real**

La POO se inspira en c√≥mo interactuamos con el mundo real. Todo a nuestro alrededor est√° compuesto por **objetos** con caracter√≠sticas (atributos) y comportamientos (m√©todos). Por ejemplo, un **carro** tiene atributos como color, marca y modelo, y m√©todos como arrancar y frenar. Adem√°s, un **conductor** puede estar asociado a un carro, estableciendo una relaci√≥n entre ambas clases.

Este mismo principio se aplica en la POO para modelar sistemas complejos. Por ejemplo, en el mundo de Minecraft, podemos tener una clase `Entidad` con atributos como `nombre` y `salud`, y subclases como `Jugador` y `Mob`. Un `Jugador` puede interactuar con diferentes `Bloques` del mundo, estableciendo una relaci√≥n de asociaci√≥n. Adem√°s, podr√≠amos modelar una clase `Inventario` que contenga m√∫ltiples `Objeto`s, como herramientas o comida, que pueden ser usados por el `Jugador`. De esta manera, podemos estructurar el sistema de Minecraft de forma modular y reutilizable, facilitando la creaci√≥n y mantenimiento del juego.

Tambi√©n podemos considerar una red social donde una clase `Usuario` tiene atributos como `nombre`, `correo` y `edad`, mientras que una clase `Publicaci√≥n` almacena contenido generado por los usuarios. Aqu√≠, cada `Usuario` puede estar asociado a m√∫ltiples `Publicaciones`, estableciendo una relaci√≥n clara entre las entidades y permitiendo modelar interacciones como "me gusta" y comentarios.

Adem√°s, podemos agregar una clase `Comentario`, que representa las respuestas a una `Publicaci√≥n`. La clase `Comentario` podr√≠a tener atributos como `autor`, `contenido` y `fecha`, y estar asociada tanto a un `Usuario` como a una `Publicaci√≥n`, creando un modelo m√°s detallado y realista de una red social.

Este enfoque permite modelar sistemas de software de manera m√°s natural y comprensible, promoviendo la reutilizaci√≥n del c√≥digo y facilitando la escalabilidad del sistema.

### **1.3 Origen e Importancia de la POO**

El paradigma de POO comenz√≥ a tomar fuerza en la d√©cada de 1960 con el lenguaje **Simula**, dise√±ado para simulaciones. En los a√±os 80, el lenguaje **Smalltalk** populariz√≥ el concepto. Luego, lenguajes como C++, Java y Python adoptaron este enfoque, convirti√©ndolo en el est√°ndar para el desarrollo de software. Hoy en d√≠a, POO es fundamental en la industria del software, ya que permite crear sistemas escalables, modulares y f√°ciles de mantener.

#### **Ejemplos de sistemas que usan POO hoy en d√≠a**

La POO es ampliamente utilizada en una variedad de aplicaciones y sistemas, entre ellos:

- **Sistemas Operativos:** Windows, macOS y Linux utilizan POO para estructurar sus componentes en m√≥dulos reutilizables.
- **Videojuegos:** Motores gr√°ficos como Unity y Unreal Engine se basan en POO para gestionar personajes, escenarios y f√≠sicas.
- **Aplicaciones M√≥viles:** Tanto Android como iOS implementan POO en sus frameworks de desarrollo (Java/Kotlin en Android, Swift/Objective-C en iOS).
- **Sistemas de Gesti√≥n Empresarial:** Software como SAP, Salesforce y ERP utilizan POO para modelar clientes, empleados y productos.
- **Redes Sociales:** Facebook, Instagram y Twitter emplean POO para gestionar usuarios, publicaciones y conexiones.
- **Aplicaciones Web:** Frameworks como Django (Python) y Spring (Java) usan POO para manejar la l√≥gica de negocio y la interacci√≥n con bases de datos.

---

## **1.4 ¬øPor qu√© es importante saber Programaci√≥n Orientada a Objetos?**

Saber POO es fundamental para cualquier desarrollador, ya que:

- Facilita la organizaci√≥n y mantenimiento del c√≥digo.
- Permite la reutilizaci√≥n de c√≥digo a trav√©s de clases y herencia.
- Mejora la escalabilidad y modularidad de los sistemas.
- Es un est√°ndar en la industria del software, usado en m√∫ltiples lenguajes y tecnolog√≠as.

### **Revisa el contexto: investigaci√≥n sugerida**

Busca en plataformas como **LinkedIn**, **Glassdoor** o **Indeed** ofertas de empleo para desarrolladores de software que mencionen **Programaci√≥n Orientada a Objetos (OOP/POO)**. Tambi√©n puedes consultar reportes de GitHub o Stack Overflow sobre tendencias en lenguajes de programaci√≥n orientados a objetos.

‚úç **Pregunta:** ¬øCu√°ntas ofertas mencionan POO como requisito? ¬øQu√© lenguajes de programaci√≥n orientados a objetos son los m√°s solicitados?

---

## **2. Conceptos Clave**

### **2.1 Diagramas UML y Diagramas de Clases**

Un **diagrama UML (Unified Modeling Language)** es una representaci√≥n gr√°fica utilizada para visualizar, especificar, construir y documentar los elementos de un sistema de software.

El **diagrama de clases** es uno de los diagramas UML m√°s importantes, ya que muestra la estructura est√°tica de un sistema al representar las clases, sus atributos, m√©todos y las relaciones entre ellas. En el contexto de la **Programaci√≥n Orientada a Objetos (POO)**, estos diagramas ayudan a visualizar c√≥mo las clases interact√∫an entre s√≠ antes de implementarlas en c√≥digo. Esto permite dise√±ar sistemas m√°s organizados y escalables, facilitando la reutilizaci√≥n y mantenimiento del software. Gracias a los diagramas UML, los desarrolladores pueden entender la arquitectura del sistema sin necesidad de revisar el c√≥digo en detalle, lo que mejora la colaboraci√≥n en equipos de trabajo.

üìå **Ejemplo en UML:**

```mermaid
classDiagram
    class Usuario {
        - string nombre
        - string correo
        - int edad
        - Publicacion [] publicaciones
        + publicarFoto()
    }
    
    class Publicacion {
        - string contenido
        - date fecha
        - int likes
        + recibirMeGusta()
    }
    
    Usuario o-- Publicacion : tiene
```

Este diagrama representa c√≥mo un `Usuario` puede crear m√∫ltiples `Publicaciones`, estableciendo una relaci√≥n clara entre ambas entidades. Para modelar mejor esta relaci√≥n, se incluye una lista de publicaciones dentro de la clase `Usuario`, lo que indica que cada usuario tiene un conjunto de publicaciones asociadas. 

#### **Reglas para representar diagramas de clases:**

- **Las clases** se representan con un rect√°ngulo dividido en tres secciones: nombre de la clase, atributos y m√©todos.
- **Los atributos** deben definirse con su tipo de dato (ejemplo: `nombre: string`).
- **Los m√©todos** deben incluir su tipo de retorno y par√°metros si los tienen (ejemplo: `+ obtenerEdad(): int`).
- **Las relaciones** entre clases se representan con l√≠neas:
  - **Asociaci√≥n**: L√≠nea simple entre clases, indica que una clase usa otra.
  - **Agregaci√≥n**: L√≠nea con un rombo vac√≠o, indica que una clase contiene a otra, pero pueden existir de manera independiente.¬†Este tipo de relaci√≥n se estudiar√° en detalle m√°s adelante en el curso, junto con otros conceptos avanzados como la agregaci√≥n y la herencia, que permiten modelar sistemas de software de manera m√°s estructurada y reutilizable.
  - **Herencia**: Flecha con tri√°ngulo, indica que una clase hereda atributos y m√©todos de otra.¬†Este tipo de relaci√≥n se estudiar√° en detalle m√°s adelante en el curso, junto con otros conceptos avanzados como la agregaci√≥n y la herencia, que permiten modelar sistemas de software de manera m√°s estructurada y reutilizable.
 
### **¬øQu√© es Mermaid y c√≥mo usarlo en Markdown para diagramas UML?**

Mermaid es una herramienta que permite generar diagramas a partir de texto en archivos Markdown. Es especialmente √∫til para representar diagramas UML dentro de documentaci√≥n en GitHub, GitLab o cualquier otro entorno compatible con Markdown.

#### **¬øC√≥mo se usa Mermaid en un archivo Markdown?**
Para incluir un diagrama UML en un archivo Markdown, utiliza la siguiente sintaxis:

```mermaid
classDiagram
    class Persona {
        - string nombre
        - int edad
        + mostrarInformacion()
    }
```
Esto generar√° un diagrama UML de clases donde `Persona` tiene atributos privados `nombre` y `edad`, y un m√©todo p√∫blico `mostrarInformacion()`.

#### **¬øD√≥nde encontrar m√°s informaci√≥n?**
Puedes aprender m√°s sobre Mermaid en su documentaci√≥n oficial: [https://mermaid.js.org/](https://mermaid.js.org/)

#### **¬øPor qu√© es √∫til?**
- Permite documentar diagramas UML directamente en archivos Markdown sin necesidad de herramientas externas.
- Facilita la colaboraci√≥n en proyectos, ya que los diagramas pueden versionarse junto con el c√≥digo.
- Es compatible con plataformas como GitHub y GitLab, lo que lo hace ideal para documentar proyectos de software.



### **2.1 Clases y Objetos**

Una **clase** es un molde o plantilla que define las caracter√≠sticas y comportamientos de un conjunto de objetos. Un **objeto** es una instancia espec√≠fica de una clase, con valores concretos para sus atributos.

üìå **Ejemplo 1:** Imagina que est√°s programando un juego de carreras. La clase `Coche` define atributos como `marca`, `color` y `velocidadM√°xima`, pero cada coche en la pista (un objeto) tendr√° valores distintos para estos atributos. Un coche rojo con velocidad m√°xima de 200 km/h y otro azul con 220 km/h son diferentes objetos de la misma clase `Coche`.

üìå **Ejemplo 2:** En una red social, la clase `Usuario` define los atributos comunes a todos los usuarios, como `nombre`, `correo` y `edad`. Sin embargo, cada usuario en la plataforma es un objeto distinto con valores espec√≠ficos, como `nombre: Juan`, `correo: juan@email.com`, `edad: 25`.

üìå **Ejemplo 3:** Piensa en una aplicaci√≥n de m√∫sica. La clase `Canci√≥n` puede definir atributos como `t√≠tulo`, `artista` y `duraci√≥n`. Cada canci√≥n en la biblioteca es un objeto √∫nico basado en esta clase, con su propio t√≠tulo, artista y duraci√≥n definidos.

### **2.2 Atributos y M√©todos**

Los **atributos** y **m√©todos** son dos de los componentes esenciales de una clase. Comprender su diferencia es clave para dise√±ar correctamente un sistema orientado a objetos.

- **Atributos:** Representan las caracter√≠sticas o datos de un objeto. Son equivalentes a las variables dentro de una clase y almacenan informaci√≥n sobre el objeto.
- **M√©todos:** Son las acciones que un objeto puede realizar. Definen su comportamiento y pueden modificar o utilizar sus atributos.

#### **¬øC√≥mo diferenciar entre un atributo y una clase?**

A veces, es dif√≠cil decidir si un elemento del sistema debe ser un atributo dentro de una clase o si debe ser una clase independiente. Aqu√≠ hay algunos consejos para ayudar en esta decisi√≥n:

1. **Si el elemento tiene caracter√≠sticas propias, probablemente sea una clase.**

   - Ejemplo: En un sistema de gesti√≥n de estudiantes, `nombre` y `edad` son atributos de un `Estudiante`, pero `Direcci√≥n` podr√≠a ser una clase separada porque tiene varios datos como `calle`, `ciudad` y `c√≥digo postal`.

2. **Si el elemento realiza acciones o tiene l√≥gica propia, debe ser una clase.**

   - Ejemplo: En un juego, un `Jugador` puede tener un atributo `puntaje`, pero si el puntaje cambia seg√∫n reglas espec√≠ficas, podr√≠a ser mejor crear una clase `Puntaje`.

3. **Si el elemento solo describe una propiedad simple, es un atributo.**

   - Ejemplo: Un `Carro` puede tener atributos como `color`, `marca` y `velocidad`, pero un `Motor` podr√≠a ser una clase separada si tiene atributos y m√©todos propios como `potencia` y `encender()`.

4. **Si el elemento puede existir independientemente de la clase principal, probablemente sea una clase.**

   - Ejemplo: Un `Libro` en una biblioteca tiene un atributo `t√≠tulo`, pero un `Autor` deber√≠a ser una clase separada porque puede escribir varios libros y tener sus propias propiedades como `nombre` y `nacionalidad`.

üìå **Ejemplo:** Un `Usuario` en una red social puede tener atributos como `nombre` y `correo`, y m√©todos como `publicarFoto()` o `enviarMensaje()`. Si se decide modelar la `Foto` como una clase separada, es porque tiene caracter√≠sticas propias como `tama√±o`, `formato` y `fechaDeSubida`.

### **2.3 Relaciones en POO**

Las **relaciones** en la Programaci√≥n Orientada a Objetos (POO) son conexiones entre clases que permiten modelar la interacci√≥n entre distintos elementos de un sistema. Estas relaciones son esenciales para construir software estructurado y reutilizable, ya que reflejan c√≥mo los objetos interact√∫an en el mundo real.

Existen varios tipos de relaciones, cada una con un prop√≥sito distinto:

- **Asociaci√≥n:** Una relaci√≥n en la que un objeto usa o interact√∫a con otro. 
- **Agregaci√≥n:** Una relaci√≥n en la que una clase contiene a otra, pero ambos objetos pueden existir independientemente.
- **Herencia:** Una relaci√≥n en la que una clase deriva de otra y hereda sus atributos y m√©todos.

Los conceptos de agregaci√≥n, composici√≥n y herencia se estudiar√°n en detalle m√°s adelante en el curso, pero por ahora nos centraremos en la asociaci√≥n, que es una de las formas m√°s comunes de relaci√≥n en POO.

A continuaci√≥n, se muestra un esquema visual de c√≥mo se representan las distintas relaciones en UML:

### **Asociaci√≥n **
```mermaid
classDiagram
    class A {
        +atributos
    }
    class B {
        +atributos
    }
    A --> B : usa
```

### **Agregaci√≥n**
```mermaid
classDiagram
    class Todo {
        +atributos
    }
    class Parte {
        +atributos
    }
    Todo o-- Parte : contiene
```

### **2.3.1 Relaciones de Asociaci√≥n**

La **asociaci√≥n** es una relaci√≥n entre dos clases en la que una clase depende o interact√∫a con otra de alguna manera. En UML, se representa con una l√≠nea simple entre las clases, y puede incluir una flecha para indicar direcci√≥n si es necesario. La asociaci√≥n no implica propiedad, solo indica que existe una relaci√≥n entre las clases.

üìå **Ejemplo:** En un videojuego como Minecraft, una clase `Jugador` puede estar asociada a una clase `Inventario`, donde cada `Jugador` tiene su propio `Inventario` que almacena objetos como herramientas y bloques.

```mermaid
classDiagram
    class Jugador {
        - string nombre
        - int nivel
        - Inventario inventario
        + usarObjeto()

    }
    class Inventario {
        - Objeto [] objetos
        + agregarObjeto()
    }

    class Objeto {
        - string nombre
        - string tipo
    }
    Jugador --> Inventario : tiene
    Inventario o--> Objeto: tiene
```

### **2.4 Encapsulamiento y Abstracci√≥n**

El **encapsulamiento** es uno de los pilares fundamentales de la Programaci√≥n Orientada a Objetos (POO). Este principio ayuda a organizar y proteger la informaci√≥n dentro de un programa, asegurando que los datos no sean modificados de manera incorrecta o accidental.

En t√©rminos simples, el encapsulamiento significa que cada objeto controla su propia informaci√≥n y solo permite que otras partes del programa accedan o modifiquen ciertos datos de manera controlada.

üìå **Ejemplo en UML:**

```mermaid
classDiagram
    class Usuario {
        - string nombre
        - int seguidores
        + seguir()
        + obtenerSeguidores()
    }
```

Aqu√≠, `nombre` y `seguidores` son atributos privados (representados con `-`), lo que significa que no pueden ser modificados directamente desde fuera de la clase. En cambio, las funciones `seguir()` y `obtenerSeguidores()` son p√∫blicas (representadas con `+`), lo que permite interactuar con los datos de una manera segura.

El encapsulamiento es clave para evitar errores y mejorar la seguridad de los programas, asegurando que cada clase solo exponga lo necesario para funcionar correctamente.

En UML, los modificadores de acceso se representan con los siguientes s√≠mbolos:

- `+` (p√∫blico): El atributo o m√©todo es accesible desde cualquier parte del c√≥digo.
- `-` (privado): Solo accesible dentro de la misma clase.
- `#` (protegido): Accesible dentro de la misma clase y sus subclases.

La **abstracci√≥n** es otro pilar fundamental de la POO. Se basa en simplificar los objetos del mundo real al enfocarse solo en sus caracter√≠sticas esenciales, ignorando los detalles innecesarios. Esto facilita la creaci√≥n de modelos m√°s claros y organizados en el software.

Un buen ejemplo de abstracci√≥n es un autom√≥vil. Cuando conduces, no necesitas conocer todos los detalles mec√°nicos del motor para usarlo. Solo interact√∫as con lo esencial: el volante, los pedales y el tablero de control. En programaci√≥n, ocurre lo mismo: definimos clases que ocultan la complejidad y solo exponen lo necesario para su uso.

üìå **Ejemplo en UML:**

```mermaid
classDiagram
    class Vehiculo {
        + acelerar()
        + frenar()
    }
```

Aqu√≠, la clase `Vehiculo` solo expone los m√©todos esenciales `acelerar()` y `frenar()`, sin mostrar c√≥mo est√°n implementados internamente. Esto permite que otros desarrolladores usen la clase sin preocuparse por su funcionamiento interno.



## **3. Ejercicios de Dise√±o de Clases**

Para dise√±ar un sistema usando Programaci√≥n Orientada a Objetos, es importante aprender a identificar qu√© elementos deben ser clases, atributos o m√©todos. A continuaci√≥n, analizaremos un caso pr√°ctico paso a paso:

üìå **Enunciado:**

Est√°s desarrollando una aplicaci√≥n para gestionar la informaci√≥n de perros y sus propietarios. El sistema maneja informaci√≥n sobre perros, sus propietarios, razas y veterinarios.

La aplicaci√≥n debe gestionar la informaci√≥n de los perros, cada uno con un nombre √∫nico, una edad, un tama√±o (grande, mediano, peque√±o) y un color. Los perros tambi√©n tienen una raza asociada, que incluye el nombre de la raza y su pa√≠s de origen.

Los propietarios son personas registradas en el sistema con un n√∫mero de identificaci√≥n √∫nico y una lista de perros a su cargo. Cada propietario puede tener varios perros bajo su cuidado.

Para la gesti√≥n de la salud de los perros, cada perro tiene un veterinario asignado. Los veterinarios son profesionales registrados en el sistema con un n√∫mero de identificaci√≥n √∫nico y detalles de contacto.

Adem√°s, debe ser posible registrar las visitas al veterinario, incluyendo el perro que fue atendido, el veterinario que lo atendi√≥, la fecha de la visita y el motivo de la visita. Un perro puede tener m√∫ltiples visitas al veterinario a lo largo del tiempo, pero cada visita espec√≠fica corresponde a un solo perro atendido por un solo veterinario en una fecha espec√≠fica.

### **Paso 1: Identificaci√≥n de Clases**

Para definir las clases, debemos encontrar los sustantivos clave en la descripci√≥n del problema. Generalmente, los sustantivos representan entidades o conceptos del mundo real que deben modelarse en el sistema. Las clases identificadas representan elementos fundamentales que interact√∫an entre s√≠ y contienen informaci√≥n relevante para la aplicaci√≥n.

Las clases deben cumplir ciertos criterios:

- Representan entidades con identidad propia dentro del sistema.
- Contienen atributos que almacenan informaci√≥n relevante.
- Pueden tener m√©todos que definen acciones que pueden realizar.

En este caso, identificamos las siguientes clases:

- `Perro`
- `Propietario`
- `Raza`
- `Veterinario`
- `VisitaVeterinaria`

### **Paso 2: Definir Atributos**

Cada clase debe tener atributos que representen sus caracter√≠sticas esenciales:

- **Perro:** `nombre`, `edad`, `tama√±o`, `color`, `raza`, `propietario`, `veterinario`
- **Propietario:** `id`, `nombre`, `listaDePerros`
- **Raza:** `nombre`, `paisOrigen`
- **Veterinario:** `id`, `nombre`, `contacto`
- **VisitaVeterinaria:** `perro`, `veterinario`, `fecha`, `motivo`

### **Paso 3: Definir M√©todos**

Los m√©todos representan acciones que las clases pueden realizar:

- **Perro:** `ladrar()`, `comer()`, `jugar()`
- **Propietario:** `registrarPerro()`, `listarPerros()`
- **Veterinario:** `realizarConsulta()`
- **VisitaVeterinaria:** `registrarVisita()`

Este an√°lisis nos ayuda a estructurar el sistema antes de representarlo gr√°ficamente. Ahora definiremos las relaciones entre las clases:

- **Un Perro pertenece a un Propietario**, pero un Propietario puede tener varios Perros (Relaci√≥n uno a muchos).
- **Un Perro tiene una Raza espec√≠fica**, pero una Raza puede estar asociada a muchos Perros (Relaci√≥n uno a muchos).
- **Un Perro tiene asignado un Veterinario**, pero un Veterinario puede atender a muchos Perros (Relaci√≥n uno a muchos).
- **Cada VisitaVeterinaria est√° asociada a un solo Perro y un solo Veterinario**, pero un Perro puede tener m√∫ltiples VisitasVeterinarias con el tiempo (Relaci√≥n muchos a uno).

Estas relaciones permiten modelar el comportamiento del sistema de manera m√°s realista y ayudar√°n a construir un diagrama UML m√°s preciso.

üìå **Diagrama UML del sistema:**

```mermaid
classDiagram
    class Perro {
        - string nombre
        - int edad
        - string tama√±o
        - string color
        + ladrar()
        + comer()
        + jugar()
    }
    
    class Propietario {
        - int id
        - string nombre
        - list<Perro> perros
        + registrarPerro()
        + listarPerros()
    }
    
    class Raza {
        - string nombre
        - string paisOrigen
    }
    
    class Veterinario {
        - int id
        - string nombre
        - string contacto
        + realizarConsulta()
    }
    
    class VisitaVeterinaria {
        - date fecha
        - string motivo
        - Perro perroVisitar
        - Veterinario veterinarioAtencion
        + registrarVisita()
    }
    
    Propietario o-- Perro : tiene
    Perro --> Raza : pertenece a
    Perro --> Veterinario : es atendido por
    Perro <-- VisitaVeterinaria 
    Veterinario <-- VisitaVeterinaria : realiza
```

Este diagrama representa c√≥mo las clases interact√∫an entre s√≠ en el sistema. Cada `Propietario` puede tener varios `Perro`s, cada `Perro` pertenece a una `Raza`, y cada `Perro` tiene un `Veterinario` asignado. Adem√°s, se registran `VisitaVeterinaria`s, en las que un `Perro` es atendido por un `Veterinario` en una fecha espec√≠fica.

### **Ejercicio 1: Pr√°ctica Independiente**

Ahora que has visto un ejemplo detallado, intenta aplicar lo aprendido a los siguientes enunciados. Para cada caso, identifica:

- Las clases que forman parte del sistema.
- Los atributos que deben tener esas clases.
- Los m√©todos necesarios para representar las acciones.
- Las relaciones entre las clases.

üìå **Enunciado:**

**Sistema de Gesti√≥n de Biblioteca:**¬† Se necesita desarrollar una aplicaci√≥n para gestionar libros en una biblioteca. La biblioteca cuenta con un cat√°logo de libros, cada uno con un t√≠tulo, autor, g√©nero y un identificador √∫nico. Los usuarios pueden registrarse en el sistema con su nombre y un n√∫mero de identificaci√≥n √∫nico.&#x20;

1. Los usuarios pueden tomar libros prestados por un per√≠odo determinado. Cada pr√©stamo debe registrar la fecha de inicio, la fecha de devoluci√≥n y el estado del libro (prestado o disponible). Un usuario puede tomar prestados varios libros a la vez, pero cada libro solo puede estar en posesi√≥n de un usuario a la vez.&#x20;
2. El sistema debe permitir las siguientes acciones:

   \- Registrar nuevos libros en la biblioteca.

   \- Registrar el pr√©stamo de un libro a un usuario.

   \- Registrar la devoluci√≥n de un libro y actualizar su estado.

   \- Mostrar la lista de libros disponibles y los que est√°n prestados.

   \- Consultar el historial de pr√©stamos de un usuario.

   El desaf√≠o consiste en identificar las clases necesarias, sus atributos y m√©todos, as√≠ como las relaciones entre ellas para finalmente hacer el diagrama UML

<details>
  <summary>üí° **Ver soluci√≥n paso a paso**</summary>

  ### **Soluci√≥n Paso a Paso**

A continuaci√≥n, resolveremos el ejercicio de gesti√≥n de biblioteca identificando clases, atributos, m√©todos y relaciones, y finalmente represent√°ndolo en un diagrama UML.

### **Paso 1: Identificaci√≥n de Clases**

Para definir las clases, analizamos los sustantivos clave en la descripci√≥n del problema. En este caso, podemos identificar las siguientes clases:

- `Libro`
- `Usuario`
- `Prestamo`

### **Paso 2: Definir Atributos**
Cada clase debe contener atributos que representen sus caracter√≠sticas esenciales:

- **Libro**: `titulo`, `autor`, `genero`, `id`, `estado`
- **Usuario**: `id`, `nombre`
- **Prestamo**: `fechaInicio`, `fechaDevolucion`, `estado`, `libro`, `usuario`

### **Paso 3: Definir M√©todos**
Los m√©todos representan acciones que las clases pueden realizar:

- **Libro**: `obtenerInformacion()`, `actualizarEstado()`
- **Usuario**: `pedirPrestado()`, `devolverLibro()`
- **Prestamo**: `registrarPrestamo(libro, usuario)`

### **Paso 4: Definir Relaciones**

- Un **Usuario** puede pedir prestados varios **Libros**.
- Un **Libro** solo puede estar en posesi√≥n de un √∫nico **Usuario** a la vez.
- Un **Prestamo** conecta un **Usuario** con un **Libro** y almacena la informaci√≥n sobre la fecha de pr√©stamo y devoluci√≥n.

### **Paso 5: Diagrama UML**

üìå **Diagrama UML del sistema:**
```mermaid
classDiagram
    class Libro {
        - string titulo
        - string autor
        - string genero
        - int id
        - string estado
        + obtenerInformacion()
        + actualizarEstado()
    }
    
    class Usuario {
        - int id
        - string nombre
        + pedirPrestado()
        + devolverLibro()
    }
    
    class Prestamo {
        - date fechaInicio
        - date fechaDevolucion
        - string estado
        + registrarPrestamo(libro, usuario)
    }
    
    Usuario "1" -- "*" Prestamo : realiza
    Prestamo "1" -- "1" Libro : incluye
    Prestamo "1" -- "1" Usuario : involucra
```

Este diagrama representa c√≥mo las clases interact√∫an en el sistema. Cada `Usuario` puede tener m√∫ltiples `Prestamo`s, y cada `Prestamo` se asocia a un solo `Libro` y un solo `Usuario`.

  </details>



### Ejercicio 2: Definir el Enunciado de un Problema a Partir de UML Diagrama : Sistema de Gesti√≥n de Pedidos en un Restaurante

### **Diagrama : Sistema de Gesti√≥n de Pedidos en un Restaurante**

```mermaid
classDiagram
    class Cliente {
        +string nombre
        +string telefono
    }
    class Pedido {
        +int numeroPedido
        +string estado
        +Cliente cliente
        +list<Plato> platos
    }
    class Plato {
        +string nombre
        +float precio
    }
    Pedido o-- Plato : contiene
    Pedido --> Cliente : pertenece a
```

**Instrucciones:**

- Interpreta el diagrama UML y redacta un enunciado que describa el sistema modelado.
- Explica las relaciones entre las clases y su importancia en el contexto del problema.
---

### Ejercicio 3: Modelando un Sistema de Control de Versiones

### Contexto

Un equipo de desarrollo utiliza Git y GitHub para gestionar el c√≥digo fuente de sus proyectos. En este sistema, los desarrolladores necesitan poder almacenar sus proyectos, realizar cambios organizados y visualizar el historial de modificaciones.

### Objetivo

Representar mediante diagramas UML un sistema de control de versiones, identificando sus elementos fundamentales y sus relaciones.

### Descripci√≥n Detallada

El sistema de control de versiones permite a los desarrolladores organizar y gestionar los cambios en el c√≥digo de un proyecto. Cada usuario representa a un programador que puede crear repositorios, modificar archivos y guardar cambios a lo largo del tiempo.

Cada **usuario** tiene un nombre y un correo electr√≥nico y puede crear m√∫ltiples **repositorios**, que act√∫an como contenedores donde se almacenan los archivos del proyecto. Dentro de un repositorio, los desarrolladores pueden realizar modificaciones en los archivos y guardar estos cambios en lo que se conoce como un **commit**.

Un **commit** es una instant√°nea del estado del c√≥digo en un momento espec√≠fico. Contiene un identificador √∫nico, un mensaje descriptivo sobre los cambios realizados, la fecha en que se guard√≥ y el usuario que lo hizo. A trav√©s de los commits, los programadores pueden visualizar el historial de modificaciones y revertir cambios si es necesario.

### Instrucciones

1. Identificar las clases principales del sistema y definir sus atributos y m√©todos.
2. Determinar las relaciones entre estas clases y su jerarqu√≠a.
3. Crear un diagrama UML que represente la estructura del sistema.


### Entrega

> SI QUIERE QUE ESTA ACTIVIDAD LE SEA REVISADA CREE ARCHIVOS EN EXTENSION .MD POR CADA MIEMBRO DEL EQUIPO EN EL REPOSITORIO Y HAGA PUSH CREADO DESDE EL GITHUB CLASSROOM

<details>
  <summary>üí° **Ver soluci√≥n **</summary>

### Soluci√≥n en UML

```mermaid
classDiagram
    class Usuario {
        -string nombre
        -string correo
        -Repositorio[] repositorios
        + agregarRepositorio()
    }

    class Repositorio {
        -string nombre
        -Commit[] historialCommits
        + agregarCommis(Usuario autor)
    }

    class Commit {
        +string id
        +string mensaje
        +string fecha
        +Usuario autor
        +Archivo[] archivosModificados
        + agregarArchivosStaggingArea()
    }

    class Archivo {
        +string nombre
        +string contenido
    }

    Usuario o-- Repositorio : posee
    Repositorio o-- Commit : almacena
    Commit o-- Archivo : modifica
    Commit --> Usuario : autor
```
</details>

#### Ejercicios extras: Diagramar a partir de un enunciado
### Objetivos

> Aplicar los conocimientos de programaci√≥n orientada a objetos para analizar una descripci√≥n de un sistema y, con base en ella, identificar y categorizar las clases, atributos, m√©todos y relaciones necesarias para modelar dicho sistema.

### Instrucciones

1. Extraer la Informaci√≥n Necesaria:
    - Seleccionar de los 6 enunciados propuestos 1 para el que quiera hacer el modelo
    - Identificar las clases involucradas en el sistema.
    - Determinar los atributos y m√©todos principales para cada elemento junto con sus relaciones. Puede agregar otros m√©todos que considere relevantes. 
    - Identificar las relaciones entre los elementos, incluyendo la cardinalidad.
    
2. Dise√±a el Diagrama UML:
    - Crear un diagrama UML que represente los elementos. Usar Mermaid para representar el diagrama y poner el c√≥digo fuente del diagrama en el README. Para que el diagrama sea renderizado correctamente.
    - Indicr claramente las relaciones de asociaci√≥n entre los elementos, especificando la cardinalidad de cada relaci√≥n.
    - Crear un archivo ``Markdown`` y copiar all√≠ el diagrama de clases final. Haga commit y push al repositorio. Escriban en el markdown los nombres de los integrantes del equipo. 

### Ejercicios
#### 1. Caso Biblioteca 

Est√°s desarrollando una aplicaci√≥n para gestionar una biblioteca. La biblioteca maneja informaci√≥n sobre libros, lectores y pr√©stamos. 

La biblioteca tiene un amplio cat√°logo de libros, cada uno con un t√≠tulo √∫nico, un c√≥digo ISBN que lo identifica de manera exclusiva y un a√±o de publicaci√≥n. Los lectores, por otro lado, son personas registradas en la biblioteca con un n√∫mero de socio √∫nico y una fecha de registro.

Para gestionar el pr√©stamo de libros, es necesario registrar cada pr√©stamo, incluyendo el libro prestado, el lector que realiza el pr√©stamo y la fecha en que se realiz√≥. Adem√°s, debe ser posible registrar cuando un libro es devuelto, actualizando as√≠ el estado del pr√©stamo.

Los lectores pueden prestar varios libros de la biblioteca a lo largo del tiempo. Sin embargo, un pr√©stamo espec√≠fico siempre corresponde a un solo libro prestado a un solo lector en una fecha espec√≠fica.

#### 2. Caso Hotel

Est√°s desarrollando una aplicaci√≥n para gestionar un sistema de reservas de hoteles. El sistema maneja informaci√≥n sobre habitaciones, hu√©spedes y reservas. 

El hotel tiene un amplio n√∫mero de habitaciones, cada una con un n√∫mero √∫nico, un tipo de habitaci√≥n (individual, doble, suite) y una tarifa por noche. Los hu√©spedes son personas registradas en el hotel con un n√∫mero de identificaci√≥n √∫nico y una fecha de registro.

Para gestionar las reservas, es necesario registrar cada reserva, incluyendo la habitaci√≥n reservada, el hu√©sped que realiza la reserva y la fecha de inicio y fin de la reserva. Adem√°s, debe ser posible actualizar el estado de la reserva a completada una vez que el hu√©sped ha hecho check-out.

Los hu√©spedes pueden hacer varias reservas a lo largo del tiempo. Sin embargo, una reserva espec√≠fica siempre corresponde a una sola habitaci√≥n reservada por un solo hu√©sped en un periodo espec√≠fico.

#### 3. Caso Tienda de Mascotas

Est√°s desarrollando una aplicaci√≥n para gestionar una cl√≠nica veterinaria. La cl√≠nica maneja informaci√≥n sobre mascotas, due√±os y citas. 

La cl√≠nica atiende a muchas mascotas, cada una con un nombre √∫nico, una especie (perro, gato, etc.) y una fecha de nacimiento. Los due√±os son personas registradas en la cl√≠nica con un n√∫mero de identificaci√≥n √∫nico y una fecha de registro.

Para gestionar las citas, es necesario registrar cada cita, incluyendo la mascota atendida, el due√±o que lleva a la mascota y la fecha y hora de la cita. Adem√°s, debe ser posible actualizar el estado de la cita a completada una vez que la mascota ha sido atendida.

Los due√±os pueden tener varias mascotas y pueden llevarlas a varias citas a lo largo del tiempo. Sin embargo, una cita espec√≠fica siempre corresponde a una sola mascota atendida por un solo due√±o en una fecha y hora espec√≠ficas.

#### 4. Caso Tienda de M√∫sica

Est√°s desarrollando una aplicaci√≥n para gestionar una tienda de m√∫sica. La tienda maneja informaci√≥n sobre √°lbumes, clientes y compras. 

La tienda tiene un amplio cat√°logo de √°lbumes, cada uno con un t√≠tulo √∫nico, un c√≥digo de identificaci√≥n y una fecha de lanzamiento. Los clientes son personas registradas en la tienda con un n√∫mero de identificaci√≥n √∫nico y una fecha de registro.

Para gestionar las compras, es necesario registrar cada compra, incluyendo el √°lbum comprado, el cliente que realiza la compra y la fecha de la compra. Adem√°s, debe ser posible registrar cuando un √°lbum es devuelto, actualizando as√≠ el estado de la compra.

Los clientes pueden comprar varios √°lbumes a lo largo del tiempo. Sin embargo, una compra espec√≠fica siempre corresponde a un solo √°lbum comprado por un solo cliente en una fecha espec√≠fica.

### 5. Caso Escuela de M√∫sica

Est√°s desarrollando una aplicaci√≥n para gestionar una escuela de m√∫sica. La escuela maneja informaci√≥n sobre cursos, estudiantes e inscripciones.

La escuela ofrece una variedad de cursos, cada uno con un nombre √∫nico, un c√≥digo de curso y una duraci√≥n en semanas. Los estudiantes son personas registradas en la escuela con un n√∫mero de identificaci√≥n √∫nico y una fecha de inscripci√≥n.

Para gestionar las inscripciones, es necesario registrar cada inscripci√≥n, incluyendo el curso en el que se inscribe, el estudiante que realiza la inscripci√≥n y la fecha de la inscripci√≥n. Adem√°s, debe ser posible registrar cuando un estudiante completa un curso, actualizando as√≠ el estado de la inscripci√≥n.

Los estudiantes pueden inscribirse en varios cursos a lo largo del tiempo. Sin embargo, una inscripci√≥n espec√≠fica siempre corresponde a un solo curso inscrito por un solo estudiante en una fecha espec√≠fica.

#### 6. Caso Galer√≠a de Arte

Est√°s desarrollando una aplicaci√≥n para gestionar una galer√≠a de arte. La galer√≠a maneja informaci√≥n sobre obras de arte, artistas y exposiciones. 

La galer√≠a tiene una colecci√≥n de obras de arte, cada una con un t√≠tulo √∫nico, un c√≥digo de identificaci√≥n y una fecha de creaci√≥n. Los artistas son personas registradas en la galer√≠a con un n√∫mero de identificaci√≥n √∫nico y una fecha de registro.

Para gestionar las exposiciones, es necesario registrar cada exposici√≥n, incluyendo la obra de arte exhibida, el artista que la cre√≥ y la fecha de la exposici√≥n. Adem√°s, debe ser posible registrar cuando una exposici√≥n termina, actualizando as√≠ el estado de la exposici√≥n.

Los artistas pueden tener varias obras de arte exhibidas a lo largo del tiempo. Sin embargo, una exposici√≥n espec√≠fica siempre corresponde a una sola obra de arte exhibida por un solo artista en una fecha espec√≠fica.


### **Recursos adicionales**

- [Editor de UML Mermaid](https://mermaid.live/edit)
- [GitHub Classroom](https://classroom.github.com)
