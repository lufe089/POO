# Gu√≠a de Estudio: Dise√±o Orientado a Objetos en C++

## **1. Introducci√≥n**

### **1.1 Conectando GitHub con la Programaci√≥n Orientada a Objetos**

Hasta ahora, has aprendido a usar Git y GitHub para gestionar versiones de c√≥digo y colaborar en proyectos. Sin embargo, escribir c√≥digo sin una estructura bien definida puede llevar a sistemas dif√≠ciles de mantener y escalar. El desarrollo de software no solo consiste en escribir c√≥digo funcional, sino tambi√©n en asegurarse de que ese c√≥digo sea claro, modular y f√°cil de modificar en el futuro. Aqu√≠ es donde entra la **Programaci√≥n Orientada a Objetos (POO)**: un enfoque que organiza el c√≥digo en **clases y objetos**, facilitando su reutilizaci√≥n y mantenimiento.

La **reutilizaci√≥n del c√≥digo** permite ahorrar tiempo y esfuerzo, evitando la necesidad de escribir las mismas funciones una y otra vez. Esto no solo optimiza el trabajo del programador, sino que tambi√©n mejora la estabilidad y consistencia del software. Por otro lado, el **mantenimiento** es clave para la evoluci√≥n de un sistema, ya que a medida que crecen los proyectos, es necesario actualizar funcionalidades, corregir errores y adaptarse a nuevos requisitos sin afectar otras partes del c√≥digo.

Muchos sistemas empresariales y aplicaciones que usamos a diario han sido desarrollados con estos principios. Desde redes sociales hasta plataformas de comercio electr√≥nico, la capacidad de reutilizar c√≥digo y mantenerlo f√°cilmente es lo que permite que estos sistemas sean escalables y confiables a lo largo del tiempo.

### **1.2 Relaci√≥n con el Mundo Real**

La POO se inspira en c√≥mo interactuamos con el mundo real. Todo a nuestro alrededor est√° compuesto por **objetos** con caracter√≠sticas (atributos) y comportamientos (m√©todos). Por ejemplo, un **carro** tiene atributos como color, marca y modelo, y m√©todos como arrancar y frenar. Adem√°s, un **conductor** puede estar asociado a un carro, estableciendo una relaci√≥n entre ambas clases.

Este mismo principio se aplica en la POO para modelar sistemas complejos. Por ejemplo, en el mundo de Minecraft, podemos tener una clase `Entidad` con atributos como `nombre` y `salud`, y subclases como `Jugador` y `Mob`. Un `Jugador` puede interactuar con diferentes `Bloques` del mundo, estableciendo una relaci√≥n de asociaci√≥n. Adem√°s, podr√≠amos modelar una clase `Inventario` que contenga m√∫ltiples `Objeto`s, como herramientas o comida, que pueden ser usados por el `Jugador`. De esta manera, podemos estructurar el sistema de Minecraft de forma modular y reutilizable, facilitando la creaci√≥n y mantenimiento del juego.

Tambi√©n podemos considerar una red social donde una clase `Usuario` tiene atributos como `nombre`, `correo` y `edad`, mientras que una clase `Publicaci√≥n` almacena contenido generado por los usuarios. Aqu√≠, cada `Usuario` puede estar asociado a m√∫ltiples `Publicaciones`, estableciendo una relaci√≥n clara entre las entidades y permitiendo modelar interacciones como "me gusta" y comentarios.

Adem√°s, podemos agregar una clase `Comentario`, que representa las respuestas a una `Publicaci√≥n`. La clase `Comentario` podr√≠a tener atributos como `autor`, `contenido` y `fecha`, y estar asociada tanto a un `Usuario` como a una `Publicaci√≥n`, creando un modelo m√°s detallado y realista de una red social.

Este enfoque permite modelar sistemas de software de manera m√°s natural y comprensible, promoviendo la reutilizaci√≥n del c√≥digo y facilitando la escalabilidad del sistema.

### **1.3 Origen e Importancia de la POO**

El paradigma de POO comenz√≥ a tomar fuerza en la d√©cada de 1960 con el lenguaje **Simula**, dise√±ado para simulaciones. En los a√±os 80, el lenguaje **Smalltalk** populariz√≥ el concepto. Luego, lenguajes como C++, Java y Python adoptaron este enfoque, convirti√©ndolo en el est√°ndar para el desarrollo de software. Hoy en d√≠a, POO es fundamental en la industria del software, ya que permite crear sistemas escalables, modulares y f√°ciles de mantener.

#### **Ejemplos de sistemas que usan POO hoy en d√≠a**

La POO es ampliamente utilizada en una variedad de aplicaciones y sistemas, entre ellos:

- **Sistemas Operativos:** Windows, macOS y Linux utilizan POO para estructurar sus componentes en m√≥dulos reutilizables.
- **Videojuegos:** Motores gr√°ficos como Unity y Unreal Engine se basan en POO para gestionar personajes, escenarios y f√≠sicas.
- **Aplicaciones M√≥viles:** Tanto Android como iOS implementan POO en sus frameworks de desarrollo (Java/Kotlin en Android, Swift/Objective-C en iOS).
- **Sistemas de Gesti√≥n Empresarial:** Software como SAP, Salesforce y ERP utilizan POO para modelar clientes, empleados y productos.
- **Redes Sociales:** Facebook, Instagram y Twitter emplean POO para gestionar usuarios, publicaciones y conexiones.
- **Aplicaciones Web:** Frameworks como Django (Python) y Spring (Java) usan POO para manejar la l√≥gica de negocio y la interacci√≥n con bases de datos.

---

## **1.4 ¬øPor qu√© es importante saber Programaci√≥n Orientada a Objetos?**

Saber POO es fundamental para cualquier desarrollador, ya que:

- Facilita la organizaci√≥n y mantenimiento del c√≥digo.
- Permite la reutilizaci√≥n de c√≥digo a trav√©s de clases y herencia.
- Mejora la escalabilidad y modularidad de los sistemas.
- Es un est√°ndar en la industria del software, usado en m√∫ltiples lenguajes y tecnolog√≠as.

### **Revisa el contexto: investigaci√≥n sugerida**

Busca en plataformas como **LinkedIn**, **Glassdoor** o **Indeed** ofertas de empleo para desarrolladores de software que mencionen **Programaci√≥n Orientada a Objetos (OOP/POO)**. Tambi√©n puedes consultar reportes de GitHub o Stack Overflow sobre tendencias en lenguajes de programaci√≥n orientados a objetos.

‚úç **Pregunta:** ¬øCu√°ntas ofertas mencionan POO como requisito? ¬øQu√© lenguajes de programaci√≥n orientados a objetos son los m√°s solicitados?

---

## **2. Conceptos Clave**

### **2.1 Diagramas UML y Diagramas de Clases**

Un **diagrama UML (Unified Modeling Language)** es una representaci√≥n gr√°fica utilizada para visualizar, especificar, construir y documentar los elementos de un sistema de software.

El **diagrama de clases** es uno de los diagramas UML m√°s importantes, ya que muestra la estructura est√°tica de un sistema al representar las clases, sus atributos, m√©todos y las relaciones entre ellas. En el contexto de la **Programaci√≥n Orientada a Objetos (POO)**, estos diagramas ayudan a visualizar c√≥mo las clases interact√∫an entre s√≠ antes de implementarlas en c√≥digo. Esto permite dise√±ar sistemas m√°s organizados y escalables, facilitando la reutilizaci√≥n y mantenimiento del software. Gracias a los diagramas UML, los desarrolladores pueden entender la arquitectura del sistema sin necesidad de revisar el c√≥digo en detalle, lo que mejora la colaboraci√≥n en equipos de trabajo.

üìå **Ejemplo en UML:**

```mermaid
classDiagram
    class Usuario {
        - string nombre
        - string correo
        - int edad
        + publicarFoto()
    }
    
    class Publicacion {
        - string contenido
        - date fecha
        + recibirMeGusta()
    }
    
    Usuario "1" -- "*" Publicacion : crea
```

Este diagrama representa c√≥mo un `Usuario` puede crear m√∫ltiples `Publicaciones`, estableciendo una relaci√≥n clara entre ambas entidades. Para modelar mejor esta relaci√≥n, se puede incluir una lista de publicaciones dentro de la clase `Usuario`, lo que indica que cada usuario tiene un conjunto de publicaciones asociadas. Esto permite gestionar de manera m√°s efectiva las interacciones dentro del sistema y visualizar mejor c√≥mo los objetos est√°n conectados en una red social.

#### **Reglas para representar diagramas de clases:**

- **Las clases** se representan con un rect√°ngulo dividido en tres secciones: nombre de la clase, atributos y m√©todos.
- **Los atributos** deben definirse con su tipo de dato (ejemplo: `nombre: string`).
- **Los m√©todos** deben incluir su tipo de retorno y par√°metros si los tienen (ejemplo: `+ obtenerEdad(): int`).
- **Las relaciones** entre clases se representan con l√≠neas:
  - **Asociaci√≥n**: L√≠nea simple entre clases, indica que una clase usa otra.
  - **Agregaci√≥n**: L√≠nea con un rombo vac√≠o, indica que una clase contiene a otra, pero pueden existir de manera independiente.¬†Este tipo de relaci√≥n se estudiar√° en detalle m√°s adelante en el curso, junto con otros conceptos avanzados como la agregaci√≥n y la herencia, que permiten modelar sistemas de software de manera m√°s estructurada y reutilizable.
  - **Composici√≥n**: L√≠nea con un rombo lleno, indica que una clase no puede existir sin la otra. Este tipo de relaci√≥n se estudiar√° en detalle m√°s adelante en el curso, junto con otros conceptos avanzados como la agregaci√≥n y la herencia, que permiten modelar sistemas de software de manera m√°s estructurada y reutilizable.
  - **Herencia**: Flecha con tri√°ngulo, indica que una clase hereda atributos y m√©todos de otra.¬†Este tipo de relaci√≥n se estudiar√° en detalle m√°s adelante en el curso, junto con otros conceptos avanzados como la agregaci√≥n y la herencia, que permiten modelar sistemas de software de manera m√°s estructurada y reutilizable.

### **2.1 Clases y Objetos**

Una **clase** es un molde o plantilla que define las caracter√≠sticas y comportamientos de un conjunto de objetos. Un **objeto** es una instancia espec√≠fica de una clase, con valores concretos para sus atributos.

üìå **Ejemplo 1:** Imagina que est√°s programando un juego de carreras. La clase `Coche` define atributos como `marca`, `color` y `velocidadM√°xima`, pero cada coche en la pista (un objeto) tendr√° valores distintos para estos atributos. Un coche rojo con velocidad m√°xima de 200 km/h y otro azul con 220 km/h son diferentes objetos de la misma clase `Coche`.

üìå **Ejemplo 2:** En una red social, la clase `Usuario` define los atributos comunes a todos los usuarios, como `nombre`, `correo` y `edad`. Sin embargo, cada usuario en la plataforma es un objeto distinto con valores espec√≠ficos, como `nombre: Juan`, `correo: juan@email.com`, `edad: 25`.

üìå **Ejemplo 3:** Piensa en una aplicaci√≥n de m√∫sica. La clase `Canci√≥n` puede definir atributos como `t√≠tulo`, `artista` y `duraci√≥n`. Cada canci√≥n en la biblioteca es un objeto √∫nico basado en esta clase, con su propio t√≠tulo, artista y duraci√≥n definidos.

### **2.2 Atributos y M√©todos**

Los **atributos** y **m√©todos** son dos de los componentes esenciales de una clase. Comprender su diferencia es clave para dise√±ar correctamente un sistema orientado a objetos.

- **Atributos:** Representan las caracter√≠sticas o datos de un objeto. Son equivalentes a las variables dentro de una clase y almacenan informaci√≥n sobre el objeto.
- **M√©todos:** Son las acciones que un objeto puede realizar. Definen su comportamiento y pueden modificar o utilizar sus atributos.

#### **¬øC√≥mo diferenciar entre un atributo y una clase?**

A veces, es dif√≠cil decidir si un elemento del sistema debe ser un atributo dentro de una clase o si debe ser una clase independiente. Aqu√≠ hay algunos consejos para ayudar en esta decisi√≥n:

1. **Si el elemento tiene caracter√≠sticas propias, probablemente sea una clase.**

   - Ejemplo: En un sistema de gesti√≥n de estudiantes, `nombre` y `edad` son atributos de un `Estudiante`, pero `Direcci√≥n` podr√≠a ser una clase separada porque tiene varios datos como `calle`, `ciudad` y `c√≥digo postal`.

2. **Si el elemento realiza acciones o tiene l√≥gica propia, debe ser una clase.**

   - Ejemplo: En un juego, un `Jugador` puede tener un atributo `puntaje`, pero si el puntaje cambia seg√∫n reglas espec√≠ficas, podr√≠a ser mejor crear una clase `Puntaje`.

3. **Si el elemento solo describe una propiedad simple, es un atributo.**

   - Ejemplo: Un `Carro` puede tener atributos como `color`, `marca` y `velocidad`, pero un `Motor` podr√≠a ser una clase separada si tiene atributos y m√©todos propios como `potencia` y `encender()`.

4. **Si el elemento puede existir independientemente de la clase principal, probablemente sea una clase.**

   - Ejemplo: Un `Libro` en una biblioteca tiene un atributo `t√≠tulo`, pero un `Autor` deber√≠a ser una clase separada porque puede escribir varios libros y tener sus propias propiedades como `nombre` y `nacionalidad`.

üìå **Ejemplo:** Un `Usuario` en una red social puede tener atributos como `nombre` y `correo`, y m√©todos como `publicarFoto()` o `enviarMensaje()`. Si se decide modelar la `Foto` como una clase separada, es porque tiene caracter√≠sticas propias como `tama√±o`, `formato` y `fechaDeSubida`.

### **2.3 Relaciones en POO**

Las **relaciones** en la Programaci√≥n Orientada a Objetos (POO) son conexiones entre clases que permiten modelar la interacci√≥n entre distintos elementos de un sistema. Estas relaciones son esenciales para construir software estructurado y reutilizable, ya que reflejan c√≥mo los objetos interact√∫an en el mundo real.

Existen varios tipos de relaciones, cada una con un prop√≥sito distinto:

- **Asociaci√≥n:** Una relaci√≥n en la que un objeto usa o interact√∫a con otro.
- **Agregaci√≥n:** Una relaci√≥n en la que una clase contiene a otra, pero ambos objetos pueden existir independientemente.
- **Composici√≥n:** Una relaci√≥n en la que una clase contiene a otra, y la existencia del objeto secundario depende del objeto principal.
- **Herencia:** Una relaci√≥n en la que una clase deriva de otra y hereda sus atributos y m√©todos.

Los conceptos de agregaci√≥n, composici√≥n y herencia se estudiar√°n en detalle m√°s adelante en el curso, pero por ahora nos centraremos en la asociaci√≥n, que es una de las formas m√°s comunes de relaci√≥n en POO.

### **2.3.1 Relaciones de Asociaci√≥n**

La **asociaci√≥n** es una relaci√≥n entre dos clases que permite que un objeto de una clase interact√∫e con un objeto de otra clase. Se utiliza para representar dependencias entre entidades dentro de un sistema.

üìå **Ejemplo:** En un videojuego como Minecraft, una clase `Jugador` puede estar asociada a una clase `Inventario`, donde cada `Jugador` tiene su propio `Inventario` que almacena objetos como herramientas y bloques.

```mermaid
classDiagram
    class Jugador {
        - string nombre
        - int nivel
        + usarObjeto()
    }
    class Inventario {
        - list objetos
        + agregarObjeto()
    }
    Jugador "1" -- "1" Inventario : posee
```

Esta relaci√≥n muestra que cada `Jugador` tiene exactamente un `Inventario`, y el `Inventario` solo pertenece a ese `Jugador`.

La **asociaci√≥n** es una relaci√≥n entre dos clases que permite que un objeto de una clase interact√∫e con un objeto de otra clase. Se utiliza para representar dependencias entre entidades dentro de un sistema.

üìå **Ejemplo:** En un videojuego como Minecraft, una clase `Jugador` puede estar asociada a una clase `Inventario`, donde cada `Jugador` tiene su propio `Inventario` que almacena objetos como herramientas y bloques.

```mermaid
classDiagram
    class Jugador {
        - string nombre
        - int nivel
        + usarObjeto()
    }
    class Inventario {
        - list objetos
        + agregarObjeto()
    }
    Jugador "1" -- "1" Inventario : posee
```

Esta relaci√≥n muestra que cada `Jugador` tiene exactamente un `Inventario`, y el `Inventario` solo pertenece a ese `Jugador`.

### **2.4 Encapsulamiento y Abstracci√≥n**

El **encapsulamiento** es uno de los pilares fundamentales de la Programaci√≥n Orientada a Objetos (POO). Este principio ayuda a organizar y proteger la informaci√≥n dentro de un programa, asegurando que los datos no sean modificados de manera incorrecta o accidental.

En t√©rminos simples, el encapsulamiento significa que cada objeto controla su propia informaci√≥n y solo permite que otras partes del programa accedan o modifiquen ciertos datos de manera controlada.

üìå **Ejemplo en UML:**

```mermaid
classDiagram
    class Usuario {
        - string nombre
        - int seguidores
        + seguir()
        + obtenerSeguidores()
    }
```

Aqu√≠, `nombre` y `seguidores` son atributos privados (representados con `-`), lo que significa que no pueden ser modificados directamente desde fuera de la clase. En cambio, las funciones `seguir()` y `obtenerSeguidores()` son p√∫blicas (representadas con `+`), lo que permite interactuar con los datos de una manera segura.

El encapsulamiento es clave para evitar errores y mejorar la seguridad de los programas, asegurando que cada clase solo exponga lo necesario para funcionar correctamente.

En UML, los modificadores de acceso se representan con los siguientes s√≠mbolos:

- `+` (p√∫blico): El atributo o m√©todo es accesible desde cualquier parte del c√≥digo.
- `-` (privado): Solo accesible dentro de la misma clase.
- `#` (protegido): Accesible dentro de la misma clase y sus subclases.

La **abstracci√≥n** es otro pilar fundamental de la POO. Se basa en simplificar los objetos del mundo real al enfocarse solo en sus caracter√≠sticas esenciales, ignorando los detalles innecesarios. Esto facilita la creaci√≥n de modelos m√°s claros y organizados en el software.

Un buen ejemplo de abstracci√≥n es un autom√≥vil. Cuando conduces, no necesitas conocer todos los detalles mec√°nicos del motor para usarlo. Solo interact√∫as con lo esencial: el volante, los pedales y el tablero de control. En programaci√≥n, ocurre lo mismo: definimos clases que ocultan la complejidad y solo exponen lo necesario para su uso.

üìå **Ejemplo en UML:**

```mermaid
classDiagram
    class Vehiculo {
        + acelerar()
        + frenar()
    }
```

Aqu√≠, la clase `Vehiculo` solo expone los m√©todos esenciales `acelerar()` y `frenar()`, sin mostrar c√≥mo est√°n implementados internamente. Esto permite que otros desarrolladores usen la clase sin preocuparse por su funcionamiento interno.



## **3. Ejercicios de Dise√±o de Clases**

Para dise√±ar un sistema usando Programaci√≥n Orientada a Objetos, es importante aprender a identificar qu√© elementos deben ser clases, atributos o m√©todos. A continuaci√≥n, analizaremos un caso pr√°ctico paso a paso:

üìå **Enunciado:**

Est√°s desarrollando una aplicaci√≥n para gestionar la informaci√≥n de perros y sus propietarios. El sistema maneja informaci√≥n sobre perros, sus propietarios, razas y veterinarios.

La aplicaci√≥n debe gestionar la informaci√≥n de los perros, cada uno con un nombre √∫nico, una edad, un tama√±o (grande, mediano, peque√±o) y un color. Los perros tambi√©n tienen una raza asociada, que incluye el nombre de la raza y su pa√≠s de origen.

Los propietarios son personas registradas en el sistema con un n√∫mero de identificaci√≥n √∫nico y una lista de perros a su cargo. Cada propietario puede tener varios perros bajo su cuidado.

Para la gesti√≥n de la salud de los perros, cada perro tiene un veterinario asignado. Los veterinarios son profesionales registrados en el sistema con un n√∫mero de identificaci√≥n √∫nico y detalles de contacto.

Adem√°s, debe ser posible registrar las visitas al veterinario, incluyendo el perro que fue atendido, el veterinario que lo atendi√≥, la fecha de la visita y el motivo de la visita. Un perro puede tener m√∫ltiples visitas al veterinario a lo largo del tiempo, pero cada visita espec√≠fica corresponde a un solo perro atendido por un solo veterinario en una fecha espec√≠fica.

### **Paso 1: Identificaci√≥n de Clases**

Para definir las clases, debemos encontrar los sustantivos clave en la descripci√≥n del problema. Generalmente, los sustantivos representan entidades o conceptos del mundo real que deben modelarse en el sistema. Las clases identificadas representan elementos fundamentales que interact√∫an entre s√≠ y contienen informaci√≥n relevante para la aplicaci√≥n.

Las clases deben cumplir ciertos criterios:

- Representan entidades con identidad propia dentro del sistema.
- Contienen atributos que almacenan informaci√≥n relevante.
- Pueden tener m√©todos que definen acciones que pueden realizar.

En este caso, identificamos las siguientes clases:

- `Perro`
- `Propietario`
- `Raza`
- `Veterinario`
- `VisitaVeterinaria`

### **Paso 2: Definir Atributos**

Cada clase debe tener atributos que representen sus caracter√≠sticas esenciales:

- **Perro:** `nombre`, `edad`, `tama√±o`, `color`, `raza`, `propietario`, `veterinario`
- **Propietario:** `id`, `nombre`, `listaDePerros`
- **Raza:** `nombre`, `paisOrigen`
- **Veterinario:** `id`, `nombre`, `contacto`
- **VisitaVeterinaria:** `perro`, `veterinario`, `fecha`, `motivo`

### **Paso 3: Definir M√©todos**

Los m√©todos representan acciones que las clases pueden realizar:

- **Perro:** `ladrar()`, `comer()`, `jugar()`
- **Propietario:** `registrarPerro()`, `listarPerros()`
- **Veterinario:** `realizarConsulta()`
- **VisitaVeterinaria:** `registrarVisita()`

Este an√°lisis nos ayuda a estructurar el sistema antes de representarlo gr√°ficamente. Ahora definiremos las relaciones entre las clases:

- **Un Perro pertenece a un Propietario**, pero un Propietario puede tener varios Perros (Relaci√≥n uno a muchos).
- **Un Perro tiene una Raza espec√≠fica**, pero una Raza puede estar asociada a muchos Perros (Relaci√≥n uno a muchos).
- **Un Perro tiene asignado un Veterinario**, pero un Veterinario puede atender a muchos Perros (Relaci√≥n uno a muchos).
- **Cada VisitaVeterinaria est√° asociada a un solo Perro y un solo Veterinario**, pero un Perro puede tener m√∫ltiples VisitasVeterinarias con el tiempo (Relaci√≥n muchos a uno).

Estas relaciones permiten modelar el comportamiento del sistema de manera m√°s realista y ayudar√°n a construir un diagrama UML m√°s preciso.

üìå **Diagrama UML del sistema:**

```mermaid
classDiagram
    class Perro {
        - string nombre
        - int edad
        - string tama√±o
        - string color
        + ladrar()
        + comer()
        + jugar()
    }
    
    class Propietario {
        - int id
        - string nombre
        - list perros
        + registrarPerro()
        + listarPerros()
    }
    
    class Raza {
        - string nombre
        - string paisOrigen
    }
    
    class Veterinario {
        - int id
        - string nombre
        - string contacto
        + realizarConsulta()
    }
    
    class VisitaVeterinaria {
        - date fecha
        - string motivo
        + registrarVisita()
    }
    
    Propietario "1" -- "*" Perro : tiene
    Perro "1" -- "1" Raza : pertenece
    Perro "1" -- "1" Veterinario : es atendido por
    Perro "1" -- "*" VisitaVeterinaria : tiene
    Veterinario "1" -- "*" VisitaVeterinaria : realiza
```

Este diagrama representa c√≥mo las clases interact√∫an entre s√≠ en el sistema. Cada `Propietario` puede tener varios `Perro`s, cada `Perro` pertenece a una `Raza`, y cada `Perro` tiene un `Veterinario` asignado. Adem√°s, se registran `VisitaVeterinaria`s, en las que un `Perro` es atendido por un `Veterinario` en una fecha espec√≠fica.

### **Ejercicio 1: Pr√°ctica Independiente**

Ahora que has visto un ejemplo detallado, intenta aplicar lo aprendido a los siguientes enunciados. Para cada caso, identifica:

- Las clases que forman parte del sistema.
- Los atributos que deben tener esas clases.
- Los m√©todos necesarios para representar las acciones.
- Las relaciones entre las clases.

üìå **Enunciado:**

**Sistema de Gesti√≥n de Biblioteca:**¬† Se necesita desarrollar una aplicaci√≥n para gestionar libros en una biblioteca. La biblioteca cuenta con un cat√°logo de libros, cada uno con un t√≠tulo, autor, g√©nero y un identificador √∫nico. Los usuarios pueden registrarse en el sistema con su nombre y un n√∫mero de identificaci√≥n √∫nico.&#x20;

1. Los usuarios pueden tomar libros prestados por un per√≠odo determinado. Cada pr√©stamo debe registrar la fecha de inicio, la fecha de devoluci√≥n y el estado del libro (prestado o disponible). Un usuario puede tomar prestados varios libros a la vez, pero cada libro solo puede estar en posesi√≥n de un usuario a la vez.&#x20;
2. El sistema debe permitir las siguientes acciones:

   \- Registrar nuevos libros en la biblioteca.

   \- Registrar el pr√©stamo de un libro a un usuario.

   \- Registrar la devoluci√≥n de un libro y actualizar su estado.

   \- Mostrar la lista de libros disponibles y los que est√°n prestados.

   \- Consultar el historial de pr√©stamos de un usuario.

   El desaf√≠o consiste en identificar las clases necesarias, sus atributos y m√©todos, as√≠ como las relaciones entre ellas para finalmente hacer el diagrama UML

<details>
  <summary>üí° **Ver soluci√≥n paso a paso**</summary>

  ### **Soluci√≥n Paso a Paso**

A continuaci√≥n, resolveremos el ejercicio de gesti√≥n de biblioteca identificando clases, atributos, m√©todos y relaciones, y finalmente represent√°ndolo en un diagrama UML.

### **Paso 1: Identificaci√≥n de Clases**

Para definir las clases, analizamos los sustantivos clave en la descripci√≥n del problema. En este caso, podemos identificar las siguientes clases:

- `Libro`
- `Usuario`
- `Prestamo`

### **Paso 2: Definir Atributos**
Cada clase debe contener atributos que representen sus caracter√≠sticas esenciales:

- **Libro**: `titulo`, `autor`, `genero`, `id`, `estado`
- **Usuario**: `id`, `nombre`
- **Prestamo**: `fechaInicio`, `fechaDevolucion`, `estado`, `libro`, `usuario`

### **Paso 3: Definir M√©todos**
Los m√©todos representan acciones que las clases pueden realizar:

- **Libro**: `obtenerInformacion()`, `actualizarEstado()`
- **Usuario**: `pedirPrestado()`, `devolverLibro()`
- **Prestamo**: `registrarPrestamo(libro, usuario)`

### **Paso 4: Definir Relaciones**

- Un **Usuario** puede pedir prestados varios **Libros**.
- Un **Libro** solo puede estar en posesi√≥n de un √∫nico **Usuario** a la vez.
- Un **Prestamo** conecta un **Usuario** con un **Libro** y almacena la informaci√≥n sobre la fecha de pr√©stamo y devoluci√≥n.

### **Paso 5: Diagrama UML**

üìå **Diagrama UML del sistema:**
```mermaid
classDiagram
    class Libro {
        - string titulo
        - string autor
        - string genero
        - int id
        - string estado
        + obtenerInformacion()
        + actualizarEstado()
    }
    
    class Usuario {
        - int id
        - string nombre
        + pedirPrestado()
        + devolverLibro()
    }
    
    class Prestamo {
        - date fechaInicio
        - date fechaDevolucion
        - string estado
        + registrarPrestamo(libro, usuario)
    }
    
    Usuario "1" -- "*" Prestamo : realiza
    Prestamo "1" -- "1" Libro : incluye
    Prestamo "1" -- "1" Usuario : involucra
```

Este diagrama representa c√≥mo las clases interact√∫an en el sistema. Cada `Usuario` puede tener m√∫ltiples `Prestamo`s, y cada `Prestamo` se asocia a un solo `Libro` y un solo `Usuario`.

  </details>



### Ejercicio 2: Definir el Enunciado de un Problema a Partir de UML Diagrama : Sistema de Gesti√≥n de Pedidos en un Restaurante

```mermaid
classDiagram
    class Cliente {
        +string nombre
        +string telefono
    }
    class Pedido {
        +int numeroPedido
        +string estado
    }
    class Plato {
        +string nombre
        +float precio
    }
    Cliente "1" -- "*" Pedido : realiza
    Pedido "1" -- "*" Plato : contiene
```

**Instrucciones:**

- Interpreta el diagrama UML y redacta un enunciado que describa el sistema modelado.
- Explica las relaciones entre las clases y su importancia en el contexto del problema.
---

### Ejercicio 3: Modelando un Sistema de Control de Versiones

### Contexto

Un equipo de desarrollo utiliza Git y GitHub para gestionar el c√≥digo fuente de sus proyectos. En este sistema, los desarrolladores necesitan poder almacenar sus proyectos, realizar cambios organizados y visualizar el historial de modificaciones.

### Objetivo

Representar mediante diagramas UML un sistema de control de versiones, identificando sus elementos fundamentales y sus relaciones.

### Descripci√≥n Detallada

El sistema de control de versiones permite a los desarrolladores organizar y gestionar los cambios en el c√≥digo de un proyecto. Cada usuario representa a un programador que puede crear repositorios, modificar archivos y guardar cambios a lo largo del tiempo.

Cada **usuario** tiene un nombre y un correo electr√≥nico y puede crear m√∫ltiples **repositorios**, que act√∫an como contenedores donde se almacenan los archivos del proyecto. Dentro de un repositorio, los desarrolladores pueden realizar modificaciones en los archivos y guardar estos cambios en lo que se conoce como un **commit**.

Un **commit** es una instant√°nea del estado del c√≥digo en un momento espec√≠fico. Contiene un identificador √∫nico, un mensaje descriptivo sobre los cambios realizados, la fecha en que se guard√≥ y el usuario que lo hizo. A trav√©s de los commits, los programadores pueden visualizar el historial de modificaciones y revertir cambios si es necesario.

Adem√°s de commits, un repositorio puede contener otros elementos importantes como:

- **Archivos y directorios:** Son los elementos que almacenan el c√≥digo fuente y la documentaci√≥n del proyecto.
- **Historial de cambios:** Un registro que muestra el orden y detalle de los commits realizados en el repositorio.

### Instrucciones

1. Identificar las clases principales del sistema y definir sus atributos y m√©todos.
2. Determinar las relaciones entre estas clases y su jerarqu√≠a.
3. Crear un diagrama UML que represente la estructura del sistema.
4. Explicar en texto el funcionamiento del modelo y los roles de cada elemento.

### Entrega

Subir la documentaci√≥n del an√°lisis y los diagramas UML a un¬† archivo Markdown en el repositorio creado desde el GitHub Classroom.

<details>
  <summary>üí° **Ver soluci√≥n **</summary>

### Soluci√≥n en UML

```mermaid
classDiagram
    class Usuario {
        +string nombre
        +string correo
        +Repositorio[] repositorios
        +crearRepositorio()
        +hacerCommit()
        +verHistorial()
    }

    class Repositorio {
        +string nombre
        +Usuario propietario
        +Commit[] historialCommits
        +Archivo[] archivos
        +agregarArchivo()
        +verHistorialCommits()
    }

    class Commit {
        +string id
        +string mensaje
        +string fecha
        +Usuario autor
        +Archivo[] archivosModificados
        +verCambios()
    }

    class Archivo {
        +string nombre
        +string contenido
        +modificarContenido()
        +verVersionAnterior()
    }

    Usuario "1" -- "*" Repositorio : posee
    Repositorio "1" -- "*" Commit : almacena
    Repositorio "1" -- "*" Archivo : contiene
    Commit "1" -- "*" Archivo : modifica
    Commit "1" -- "1" Usuario : autor
```
</details>

### **Recursos adicionales**

- [Editor de UML Mermaid](https://mermaid.live/edit)
- [GitHub Classroom](https://classroom.github.com)
