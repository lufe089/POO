# Secci√≥n 1. Introducci√≥n a la STL y a los Contenedores en C++

## 1.1 ¬øQu√© es la STL?

La STL (*Standard Template Library*) es una biblioteca est√°ndar de C++ que proporciona un conjunto de herramientas gen√©ricas reutilizables para facilitar la programaci√≥n eficiente y estructurada. Esta biblioteca incluye:

- **Contenedores**: estructuras que permiten almacenar y organizar colecciones de datos.
- **Iteradores**: objetos que permiten recorrer los elementos de un contenedor.
- **Algoritmos**: funciones predefinidas para realizar operaciones como ordenamiento, b√∫squeda, transformaci√≥n y eliminaci√≥n.

La STL permite resolver problemas comunes sin necesidad de implementar estructuras de datos desde cero. Es una herramienta fundamental para el desarrollo moderno en C++, ampliamente utilizada en la industria.

---

## 1.2 ¬øQu√© es un contenedor?

### 1.2.1 Analog√≠as cotidianas

Para comprender qu√© es un contenedor, puede ser √∫til considerar algunas analog√≠as:

- Una **fila de supermercado** representa una lista de personas organizadas en orden de llegada.
- Una **agenda de contactos** asocia nombres con n√∫meros telef√≥nicos, como un diccionario.
- Una **caja de marcadores** donde no se permiten colores repetidos es similar a un conjunto sin duplicados.

En programaci√≥n, los contenedores cumplen funciones similares: permiten organizar, acceder y manipular colecciones de datos.

### 1.2.2 Tipado de los contenedores

Antes de utilizar un contenedor en C++, es necesario especificar el **tipo de dato** que va a almacenar. Esta caracter√≠stica se basa en el uso de **plantillas (templates)**. Por ejemplo:

```cpp
#include <vector>
#include <set>
#include <map>
#include <string>

int main() {
    std::vector<int> numeros;            // Contenedor de enteros
    std::set<std::string> nombres;       // Conjunto de cadenas de texto
    std::map<std::string, float> notas;  // Diccionario de nombres con notas
    return 0;
}
```

Cuando se almacenan **tipos primitivos** (como `int`, `float`, `char`, etc.), generalmente se hace directamente. En cambio, cuando se trabaja con **objetos**, se recomienda almacenar **punteros a objetos** en lugar de los objetos completos, ya que permite una mejor gesti√≥n de la memoria, evita copias costosas y facilita el uso de polimorfismo.

<details>
<summary>üìå Nota: ¬øCu√°l es la diferencia entre almacenar objetos y punteros?</summary>

- **Paso por copia**: se crea una copia del objeto. Es costoso si el objeto es grande.
- **Paso por referencia**: se accede al mismo objeto original, sin copiarlo.
- **Uso de punteros**: permite crear objetos en memoria din√°mica, compartirlos entre estructuras y eliminarlos de forma controlada.

```cpp
#include <vector>

class Estudiante {}; // Clase de ejemplo

int main() {
    std::vector<Estudiante> lista1;       // Almacena copias completas de objetos Estudiante
    std::vector<Estudiante*> lista2;      // Almacena punteros a objetos Estudiante
    return 0;
}
```

En programaci√≥n orientada a objetos, es com√∫n trabajar con `vector<Clase*>`, especialmente cuando los objetos tienen m√©todos virtuales o se comparten entre clases.

</details>

### 1.2.3  Tipos de ciclos para recorrer colecciones

En C++, existen varias formas de recorrer los elementos de una colecci√≥n. A continuaci√≥n se describen las tres m√°s utilizadas:

#### Ciclo `for` cl√°sico con √≠ndice

Este tipo de ciclo se utiliza especialmente con contenedores que permiten acceso por posici√≥n, como `vector`. Su estructura es:

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> contenedor = {1, 2, 3};

    for (size_t i = 0; i < contenedor.size(); i++) {
        std::cout << contenedor[i] << std::endl;
    }
    return 0;
}
```
- Se inicializa una variable de control (por lo general `i = 0`).
- Se define una condici√≥n que se eval√∫a antes de cada iteraci√≥n (`i < contenedor.size()`).
- Se incrementa la variable al final de cada ciclo (`i++`).

#### Ciclo `for` basado en rango

Este ciclo recorre autom√°ticamente todos los elementos de un contenedor sin usar √≠ndices. Es √∫til y claro para la mayor√≠a de los casos:

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> contenedor = {1, 2, 3};

    for (const int& elemento : contenedor) {
        std::cout << elemento << std::endl;
    }
    return 0;
}
```
- `const` evita modificar el elemento.
- `&` evita realizar una copia innecesaria (especialmente √∫til si `Tipo` es un objeto).

#### Ciclo usando iteradores expl√≠citos

Se basa en el uso de objetos especiales llamados **iteradores**, que permiten recorrer elementos desde el primero (`begin()`) hasta el final (`end()`):

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> contenedor = {1, 2, 3};

    for (auto it = contenedor.begin(); it != contenedor.end(); ++it) {
        std::cout << *it << std::endl;
    }
    return 0;
}
```
- `auto` deduce autom√°ticamente el tipo del iterador.
- El asterisco `*it` se usa para acceder al valor que apunta el iterador.

Esta forma es necesaria cuando se quiere modificar elementos directamente o se requiere un mayor control sobre el recorrido.

---

## 1.3 Contenedores fundamentales de la STL

La STL agrupa los contenedores en tres grandes categor√≠as:

- **Contenedores secuenciales**: almacenan elementos en un orden determinado.
  - Ejemplos: `vector`, `list`, `deque`

- **Contenedores asociativos**: organizan los elementos de acuerdo con llaves. No mantienen un orden secuencial. NO es posible seleccionar la posici√≥n de inserci√≥n.
  - Ejemplos: `set`, `map`, `multimap`, `multiset`

- **Contenedores adaptadores**: modifican el comportamiento de otros contenedores.
  - Ejemplos: `stack`, `queue`, `priority_queue`

En esta gu√≠a se trabajar√° principalmente con `vector`, `set` y `map`, por ser los m√°s √∫tiles para el desarrollo de aplicaciones orientadas a objetos en etapas iniciales.


### 1.3.1 `vector<T>`

#### Definici√≥n y analog√≠a

Un `vector` es una lista ordenada de elementos, de tama√±o variable. Es similar a un arreglo din√°mico que puede crecer o reducirse seg√∫n sea necesario.

#### Beneficios
- Permite acceso r√°pido por √≠ndice.
- F√°cil de recorrer.
- Flexible: se pueden a√±adir o eliminar elementos din√°micamente.

#### Limitaciones
- Inserciones o eliminaciones en medio del `vector` pueden ser costosas.

#### Operaciones b√°sicas y formas de recorrido
```cpp
vector<int> numeros;
numeros.push_back(10);
numeros.push_back(20);

// Recorrido con √≠ndice cl√°sico
for (int i = 0; i < numeros.size(); i++) {
    cout << numeros[i] << endl;
}
// Partes del ciclo for cl√°sico:
// - inicializaci√≥n: int i = 0
// - condici√≥n: i < numeros.size()
// - incremento: i++

// Recorrido con for basado en rango
for (const int& n : numeros) {
    cout << n << endl;
}
// Se recomienda usar const y referencia (&) para evitar copias

// Recorrido con iteradores expl√≠citos
for (auto it = numeros.begin(); it != numeros.end(); ++it) {
    cout << *it << endl;
}
```

---

### 1.3.2 `set<T>`

#### Definici√≥n y analog√≠a

Un `set` es una colecci√≥n de elementos √∫nicos, organizados de forma ordenada autom√°ticamente. Es similar a una caja donde no se permiten duplicados.

#### Beneficios
- Garantiza la unicidad de los elementos.
- Permite b√∫squeda eficiente.

#### Limitaciones
- No permite acceder por √≠ndice.
- Los elementos deben ser comparables (operador `<`).

#### Operaciones b√°sicas y formas de recorrido
```cpp
set<string> nombres;
nombres.insert("Ana");
nombres.insert("Luis");
nombres.insert("Ana");

// For basado en rango
for (const string& nombre : nombres) {
    cout << nombre << endl;
}

// Iteradores expl√≠citos
for (auto it = nombres.begin(); it != nombres.end(); ++it) {
    cout << *it << endl;
}
```

---

### 1.3.3 `map<K, V>`

#### Definici√≥n y analog√≠a

Un `map` es una estructura que asocia llaves con valores. Es comparable a una agenda, donde a cada nombre se le asigna un n√∫mero telef√≥nico.

#### Beneficios
- Permite acceder a un valor usando una llave.
- No permite llaves duplicadas.

#### Limitaciones
- Las llaves deben ser √∫nicas y comparables.

#### Operaciones b√°sicas y formas de recorrido
```cpp
map<string, int> edades;
edades["Ana"] = 15;
edades["Luis"] = 16;
edades["Carlos"] = 17;

// Recorrido usando for basado en rango
for (const pair<const string, int>& par : edades) {
    cout << par.first << ": " << par.second << endl;
}

// Iteradores expl√≠citos
for (auto it = edades.begin(); it != edades.end(); ++it) {
    cout << it->first << ": " << it->second << endl;
}
```

üîπ `auto` permite que el compilador infiera el tipo. Se recomienda `const auto&` para evitar copias cuando se recorren objetos complejos.


### Ejemplo de uso de set y map
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> contenedor = {1, 2, 3};

    for (auto it = contenedor.begin(); it != contenedor.end(); ++it) {
        std::cout << *it << std::endl;
    }
    return 0;
}
```
---

### Ejercicios

A continuaci√≥n se presentan algunos ejercicios para pr√°cticar. Para facilitar el desarrollo y la organizaci√≥n de los ejercicios, se propone crear una clase auxiliar denominada `Prueba`. Esta clase contendr√° los m√©todos de prueba para cada tipo de contenedo y un men√∫ simple para probar cada elemento de la STL desde consola, con la clase `Prueba`:

```cpp
int main() {
    Prueba objPrueba;
    int opcion;
    do {
        cout << "\nSeleccione una opci√≥n:\n";
        cout << "1. Probar vector\n";
        cout << "2. Probar set\n";
        cout << "3. Probar map\n";
        cout << "0. Salir\n";
        cin >> opcion;

        switch(opcion) {
            case 1: objPrueba.probarVector(); break;
            case 2: objPrueba.probarSet(); break;
            case 3: objPrueba.probarMap(); break;
        }
    } while(opcion != 0);

    return 0;
}
```
> Cree el objeto objPrueba tambi√©n usando memoria din√°mica ( use `new` y `delete` y observe como cambia la sintaxis para el llamado de los m√©todos)


#### Ejercicio 1. Lista de nombres

Crear un `vector<string>` que almacene cinco nombres. Mostrar los nombres por consola usando diferentes formas de recorrido.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <vector>
#include <string>
#include <iostream>

void probarVector() {
    std::vector<std::string> nombres = {"Ana", "Luis", "Carlos", "Marta", "Juli√°n"};

    for (const std::string& nombre : nombres) {
        std::cout << nombre << std::endl;
    }
}
```

</details>

---

#### Ejercicio 2. Conjunto sin duplicados

Crear un `set<string>` e insertar nombres con duplicados. Mostrar los elementos del conjunto resultante.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <set>
#include <string>
#include <iostream>

void probarSet() {
    std::set<std::string> nombres;
    nombres.insert("Ana");
    nombres.insert("Luis");
    nombres.insert("Ana");
    nombres.insert("Carlos");

    for (auto it = nombres.begin(); it != nombres.end(); ++it) {
        std::cout << *it << std::endl;
    }
}
```

</details>

---

#### Ejercicio 3. Diccionario de edades

Crear un `map<string, int>` para almacenar tres nombres y sus edades. Mostrar todos los pares almacenados.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <map>
#include <string>
#include <iostream>

void probarMap() {
    std::map<std::string, int> edades;
    edades["Ana"] = 15;
    edades["Luis"] = 16;
    edades["Carlos"] = 17;

    for (const auto& par : edades) {
        std::cout << par.first << ": " << par.second << " a√±os" << std::endl;
    }
}
```

</details>

## Secci√≥n 2 Iteradores en C++

### 2.1 ¬øQu√© es un iterador?

Un **iterador** es un objeto que act√∫a como un puntero para recorrer una estructura de datos. Permite acceder secuencialmente a los elementos de un contenedor sin exponer c√≥mo est√°n almacenados internamente.

### üì¶ Analog√≠a cotidiana

Piensa en una **cinta transportadora** en una f√°brica de chocolates. Cada dulce pasa frente a ti, uno por uno. T√∫ (el iterador) no necesitas saber d√≥nde est√°n almacenados todos los dulces, solo necesitas un mecanismo para ver el siguiente.

<details>
<summary>C√≥digo de ejemplo</summary>

```cpp
std::vector<std::string> tareas = {"Lavar", "Cocinar", "Estudiar"};
auto it = tareas.begin(); // Iterador apuntando al primer elemento
std::cout << *it; // El asterisco (*) se usa para acceder al valor al que apunta el iterador         // Accede al valor apuntado: "Lavar"
```

</details>

---

### 2.2 ¬øPor qu√© usar iteradores?

- Son **necesarios** cuando se usan funciones gen√©ricas de la STL (como `sort`, `find`, etc.).
- Permiten **modificar elementos** directamente durante el recorrido.
- Funcionan de forma **uniforme** para diferentes tipos de contenedores. Funcionan de forma uniforme para diferentes tipos de contenedores. Esto significa que, sin importar si estamos utilizando un vector, un set o un map, podemos recorrer sus elementos utilizando la misma l√≥gica basada en iteradores. Esta caracter√≠stica facilita el desarrollo de funciones gen√©ricas que pueden aplicarse a distintos tipos de estructuras, sin necesidad de adaptar el c√≥digo a cada una. Por ejemplo, podemos crear una funci√≥n que imprima los elementos de cualquier colecci√≥n utilizando simplemente sus iteradores, sin tener que saber c√≥mo est√°n almacenados internamente los datos ni preocuparse por si el contenedor permite acceso por √≠ndice o no.

### Diferencias con otros ciclos

| Tipo de recorrido     | ¬øUsa √≠ndices? | ¬øRequiere conocer tama√±o? | ¬øPermite modificar? | ¬øUsa iteradores? |
|----------------------|---------------|----------------------------|---------------------|------------------|
| `for` cl√°sico        | S√≠            | S√≠                         | S√≠                  | No               |
| `for` basado en rango| No            | No                         | No (si es `const`)  | Internamente s√≠  |
| Iterador expl√≠cito   | No            | No                         | S√≠                  | S√≠               |

---

### 2.3 ¬øCu√°ndo es obligatorio usar iteradores?

‚úÖ Obligatorio:
- Al usar algoritmos de la STL (`find`, `sort`, etc.).
- Para recorrer `set`, `map`, `list`, donde no hay acceso por √≠ndice.
- Para modificar elementos mientras se recorren (sin invalidar el ciclo).

‚ùå No necesario:
- Para contenedores con acceso aleatorio (`vector`) cuando solo se requiere leer valores.

---


### üìù Ejemplos

- Crear un `set<string>` con nombres de personas y recorrerlo usando un iterador para imprimir solo los nombres que tienen m√°s de 4 letras.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <iostream>
#include <set>
#include <string>

int main() {
    std::set<std::string> nombres = {"Ana", "Santiago", "Luis", "Camila"};

    for (auto it = nombres.begin(); it != nombres.end(); ++it) {
        if (it->size() > 4) {
            std::cout << *it << std::endl;
        }
    }
    return 0;
}
```

</details>

- Crear un `map<string, float>` de productos y precios. Usar iterador para aplicar un descuento del 10% a todos los productos.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, float> productos = {
        {"Pan", 1000}, {"Leche", 2500}, {"Queso", 3500}
    };

    for (auto it = productos.begin(); it != productos.end(); ++it) {
        it->second *= 0.9; // Aplicar 10% de descuento
        std::cout << it->first << ": $" << it->second << std::endl;
    }
    return 0;
}
```

</details>

---

## 3 Algoritmos de la STL

### 3.1 ¬øQu√© son los algoritmos?

Son funciones gen√©ricas que operan sobre secuencias (contenedores). Se definen en `<algorithm>` y requieren **iteradores** como argumentos.

```cpp
#include <algorithm>
#include <vector>
```

---

### 3.2 Ejemplos y analog√≠as de uso

##### üîç `find`: Buscar un elemento

‚ö†Ô∏è Nota importante sobre find en distintos contenedores:

* En vector, std::find sirve para buscar un valor. El iterador obtenido permite acceder y modificar el elemento encontrado.
* En set, std::find retorna un iterador que permite leer el valor, pero no modificarlo, ya que los elementos en un set son constantes.
* En map, std::find retorna un iterador que apunta a un par llave-valor (std::pair<const Key, Value>). Es posible modificar el valor usando it->second, pero no  es posible modificar la llave.

**Analog√≠a**: Buscar un nombre en una lista de asistencia.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

int main() {
    std::vector<std::string> lista = {"Ana", "Luis", "Carlos"};
    auto it = std::find(lista.begin(), lista.end(), "Luis");

    if (it != lista.end()) {
        std::cout << "Encontrado: " << *it << std::endl;
        *it = "Luis Miguel"; // Modificamos el valor encontrado
        std::cout << "Modificado: " << *it << std::endl;
    } else {
        std::cout << "No encontrado." << std::endl;
    }
    return 0;
}
```

>En Map
```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> edades = {
        {"Ana", 21}, {"Luis", 22}, {"Carlos", 23}
    };
    auto it = edades.find("Luis");

    if (it != edades.end()) {
        std::cout << it->first << " tiene " << it->second << " a√±os." << std::endl;
        it->second += 1; // Cumplea√±os: aumentamos la edad
        std::cout << "Ahora tiene " << it->second << " a√±os." << std::endl;
    } else {
        std::cout << "No encontrado." << std::endl;
    }
    return 0;
}
```
---

#### üî¢ `count`: Contar ocurrencias

**Analog√≠a**: Contar cu√°ntas veces alguien lleg√≥ tarde en un mes.
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> llegadas = {1, 0, 1, 1, 0};
    int total = std::count(llegadas.begin(), llegadas.end(), 1);
    std::cout << "D√≠as tarde: " << total << std::endl;
    return 0;
}
```

---

##### üî† `sort`: Ordenar elementos

**Analog√≠a**: Ordenar calificaciones de mayor a menor.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> notas = {3, 5, 4, 2};
    std::sort(notas.begin(), notas.end(), std::greater<int>());

    for (int n : notas) {
        std::cout << n << " ";
    }
    return 0;
}
```

##### üßÆ `accumulate`: Sumar elementos

**Analog√≠a**: Calcular el total de gastos del mes.

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> gastos = {100, 200, 150};
    int total = std::accumulate(gastos.begin(), gastos.end(), 0);
    std::cout << "Total: " << total << std::endl;
    return 0;
}
```

##### üßπ `remove`: Eliminar (l√≥gicamente) un elemento

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {1, 2, 3, 2, 4};
    auto fin = std::remove(numeros.begin(), numeros.end(), 2);
    numeros.erase(fin, numeros.end());

    for (int n : numeros) {
        std::cout << n << " ";
    }
    return 0;
}


> üõë `remove` solo mueve los elementos no eliminados al principio. Hay que llamar `erase()` para ajustar el tama√±o.

---

## üß© 3.4 Relaci√≥n entre iteradores y algoritmos

Los algoritmos **no trabajan directamente con contenedores**, sino con sus **iteradores**. Esto los hace m√°s flexibles: un mismo algoritmo puede usarse sobre `vector`, `set`, `list`, etc.

---

## üìù Ejercicios pr√°cticos

### Ejercicio 1: Buscar

Crear un `vector<string>` con nombres. Pedir al usuario un nombre y usar `find` para verificar si est√° en la lista.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

int main() {
    std::vector<std::string> nombres = {"Ana", "Luis", "Carlos"};
    std::string buscar;
    std::cout << "Ingrese el nombre a buscar: ";
    std::cin >> buscar;

    auto it = std::find(nombres.begin(), nombres.end(), buscar);
    if (it != nombres.end()){
        std::cout << "Encontrado: " << *it << std::endl;
    }
    else {
        std::cout << "No encontrado." << std::endl;
    }
    return 0;
}
```

</details>

### Ejercicio 2: Contar

Usar `count` para contar cu√°ntas veces aparece un n√∫mero en un `vector<int>`.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {2, 3, 2, 5, 2, 1};
    int total = std::count(numeros.begin(), numeros.end(), 2);
    std::cout << "El n√∫mero 2 aparece " << total << " veces." << std::endl;
    return 0;
}
```

</details>

### Ejercicio 3: Ordenar

Crear un vector de calificaciones y ordenarlas de mayor a menor usando `sort`.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> calificaciones = {3, 5, 4, 2};
    std::sort(calificaciones.begin(), calificaciones.end(), std::greater<int>());

    for (int nota : calificaciones){
        std::cout << nota << " ";
    }
    return 0;
}
```

</details>

### Ejercicio 4: Acumular

Sumar todos los gastos registrados en un vector.

<details>
<summary>Soluci√≥n sugerida</summary>

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> gastos = {1000, 2500, 3200};
    int total = std::accumulate(gastos.begin(), gastos.end(), 0);
    std::cout << "Total de gastos: $" << total << std::endl;
    return 0;
}
```

</details>



